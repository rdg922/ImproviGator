

---
title: JavaScript API
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Pattern Functions

Let's learn all about functions to create and modify patterns.
At the core of Strudel, everything is made of functions.

For example, everything you can do with the Mini-Notation can also be done with a function.
This Pattern in Mini Notation:

<MiniRepl client:only="react" tune={`note("c3 eb3 g3")`} />

is equivalent to this Pattern without Mini Notation:

<MiniRepl client:only="react" tune={`note(seq("c3", "eb3", "g3"))`} />

Similarly, there is an equivalent function for every aspect of the mini notation.

Which representation to use is a matter of context. As a rule of thumb, functions
are better suited in a larger context, while mini notation is more practical for individual rhythms.

## Limits of Mini Notation

While the Mini Notation is a powerful way to write rhythms concisely, it also has its limits. Take this example:

<MiniRepl
  client:idle
  tune={`stack(
  note("c2 eb2(3,8)").s('sawtooth').cutoff(800),
  s("bd(5,8), hh*8")
)`}
/>

Here, we are using mini notation for the individual rhythms, while using the function `stack` to mix them.
While stack is also available as `,` in mini notation, we cannot use it here, because we have different types of sounds.

## Combining Patterns

You can freely mix JS patterns, mini patterns and values! For example, this pattern:

<MiniRepl
  client:idle
  tune={`cat(
  stack("g3","b3","e4"),
  stack("a3","c3","e4"),
  stack("b3","d3","fs4"),
  stack("b3","e4","g4")
).note()`}
/>

...is equivalent to:

<MiniRepl
  client:idle
  tune={`cat(
  "g3,b3,e4",
  "a3,c3,e4",
  "b3,d3,f#4",
  "b3,e4,g4"
).note()`}
/>

... as well as:

<MiniRepl client:only="react" tune={`note("<[g3,b3,e4] [a3,c3,e4] [b3,d3,f#4] [b3,e4,g4]>")`} />

While mini notation is almost always shorter, it only has a handful of modifiers: \* / ! @.
When using JS patterns, there is a lot more you can do.

Next, let's look at how you can [create patterns](/learn/factories)


---
title: Control Parameters
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Control Parameters

Besides functions that control time, we saw earlier that functions like `note` and `cutoff` control different parameters (short params) of an event.
Let's now look more closely at how these `param(eter) functions` work.

# Parameter Functions

A very powerful feature of tidal patterns is that each parameter can be controlled independently:

<MiniRepl
  client:only="react"
  tune={`note("c a f e")
.cutoff("<500 1000 2000 [4000 8000]>")
.gain(.8)
.s('sawtooth')
.log()`}
/>

In this example, the parameters `note`, `cutoff`, `gain` and `s` are controlled independently by either patterns or plain values (numbers / text).
After pressing play, we can observe the time and parameter values of each event (hap) in the output created by `.log()`.

## Plain vs Parameterized Values

Patterns that are not wrapped inside a param function will contain unlabeled `plain values`:

<MiniRepl client:only="react" tune={`"<c e g>".log()`} />

This will not generate any sound output, because Strudel could only guess which param is meant by these letters.

Now compare that to the version wrapped in `note`:

<MiniRepl client:only="react" tune={`note("<c e g>").log()`} />

Now it is clear that these letters are meant to be played as notes.
Under the hood, the `note` function (as well as all other param functions)
will wrap each plain value in an object. If the note function did not exist, we would need to write:

<MiniRepl client:only="react" tune={`cat({note:'c'},{note:'e'},{note:'g'}).log()`} />

This will have the same output, though it is rather unwieldy to read and write.

## Wrapping Parameter Functions

To avoid too much nesting, param functions can also be chained like this:

<MiniRepl client:only="react" tune={`cat('c', 'e', 'g').note().log()`} />

This is equivalent to `note(cat('c','e','g')).log()`.

You can use this with any function that declares a type (like `n`, `s`, `note`, `freq` etc), just make sure to leave the parens empty!

## Plain Value Modification

Patterns of plain values can be modified with any of the following operators:

<MiniRepl client:only="react" tune={`"50 60 70".add("<0 1 2>").log()`} />

Here, the add function modifies the numbers on the left.
Again, there is no output because these numbers have no meaning without a param.

## Param Value Modification

To modify a parameter value, you can either:

- Use the operator on the plain value pattern, inside the param function:

  <MiniRepl client:only="react" tune={`note("50 60 70".add("<0 1 2>")).room(.1).log()`} />

- Similarly, use the operator on the plain value pattern and wrap it later:

  <MiniRepl client:only="react" tune={`"50 60 70".add("<0 1 2>").note().room(.1).log()`} />

- Specify which param should be modified inside the operator function:

  <MiniRepl client:only="react" tune={`note("50 60 70").room(.1).add(note("<0 1 2>")).log()`} />

Remember the execution of the chained functions goes from left to right.

# Operators

This group of functions allows to modify the value of events.

## add

<JsDoc client:idle name="Pattern.add" h={0} />

## sub

<JsDoc client:idle name="Pattern.sub" h={0} />

## mul

<JsDoc client:idle name="Pattern.mul" h={0} />

## div

<JsDoc client:idle name="Pattern.div" h={0} />

## round

<JsDoc client:idle name="Pattern.round" h={0} />

## floor

<JsDoc client:idle name="Pattern.floor" h={0} />

## ceil

<JsDoc client:idle name="Pattern.ceil" h={0} />

## range

<JsDoc client:idle name="Pattern.range" h={0} />

## rangex

<JsDoc client:idle name="Pattern.rangex" h={0} />

## range2

<JsDoc client:idle name="Pattern.range2" h={0} />

## ratio

<JsDoc client:idle name="Pattern.ratio" h={0} />

## as

<JsDoc client:idle name="as" h={0} />

# Custom Parameters

You can also create your own parameters:

<MiniRepl
  client:only="react"
  tune={`let x = createParam('x')
x(sine.range(0, 200))
`}
/>

Multiple params can also be created in a more consice way, using `createParams`:

<MiniRepl
  client:only="react"
  tune={`let { x, y } = createParams('x', 'y');
x(sine.range(0, 200)).y(cosine.range(0, 200));
`}
/>

Note that these params will not do anything until you give them meaning in your custom output!

From modifying parameters we transition to the concept of [Signals](/learn/signals).


---
title: Showcase
layout: ../../layouts/MainLayout.astro
---

import { Showcase } from '../../components/Showcase';

# Showcase

This page contains a randomly shuffled selection of videos that show people using strudel in some way.

<Showcase client:only="react" />


---
title: Accumulation Modifiers
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Accumulation Modifiers

## superimpose

<JsDoc client:idle name="Pattern.superimpose" h={0} />

## layer

<JsDoc client:idle name="Pattern.layer" h={0} />

## off

<JsDoc client:idle name="Pattern.off" h={0} />

## echo

<JsDoc client:idle name="Pattern.echo" h={0} />

## echoWith

<JsDoc client:idle name="echoWith" h={0} />

## stut

<JsDoc client:idle name="stut" h={0} />

There are also [Tonal Functions](/learn/tonal).


---
title: Coding syntax
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Coding Syntax

Let's take a step back and understand how the syntax in Strudel works.

Take a look at this simple example:

<MiniRepl client:idle tune={`note("c a f e").s("piano")`} />

- We have a word `note` which is followed by some brackets `()` with some words/letters/numbers inside, surrounded by quotes `"c a f e"`
- Then we have a dot `.` followed by another similar piece of code `s("piano")`.
- We can also see these texts are _highlighted_ using colours: word `note` is purple, the brackets `()` are grey, and the content inside the `""` are green. (The colors could be different if you've changed the default theme)

What happens if we try to 'break' this pattern in different ways?

<MiniRepl client:idle tune={`note(c a f e).s(piano)`} />

<MiniRepl client:idle tune={`note("c a f e")s("piano")`} />

<MiniRepl client:idle tune={`note["c a f e"].s{"piano"}`} />

Ok, none of these seem to work...

<MiniRepl client:idle tune={`s("piano").note("c a f e")`} />

This one does work, but now we only hear the first note...

So what is going on here?

# Functions, arguments and chaining

So far, we've seen the following syntax:

```
xxx("foo").yyy("bar")
```

Generally, `xxx` and `yyy` are called [_functions_](<https://en.wikipedia.org/wiki/Function_(computer_programming)>), while `foo` and `bar` are called function [_arguments_ or _parameters_](<https://en.wikipedia.org/wiki/Parameter_(computer_programming)>).
So far, we've used the functions to declare which aspect of the sound we want to control, and their arguments for the actual data.
The `yyy` function is called a [_chained_ function](https://en.wikipedia.org/wiki/Method_chaining), because it is preceded with a dot (`.`).

Generally, the idea with chaining is that code such as `a("this").b("that").c("other")` allows `a`, `b` and `c` functions to happen in a specified order, without needing to write them as three separate lines of code.
You can think of this as being similar to chaining audio effects together using guitar pedals or digital audio effects.

Strudel makes heavy use of chained functions. Here is a more sophisticated example:

<MiniRepl
  client:idle
  tune={`note("a3 c#4 e4 a4")
.s("sawtooth")
.cutoff(500)
//.delay(0.5)
.room(0.5)`}
/>

## Write your own chained function

You can write your own chained function using `register`. Here's the above chain but registered as a reusable, chained function.

<MiniRepl
  client:idle
  tune={`const effectChain = register('effectChain', (pat) => pat
    .s("sawtooth")
    .cutoff(500)
    //.delay(0.5)
    .room(0.5)
  )
note("a3 c#4 e4 a4").effectChain()`}
/>

Try adding `.rev()` after `effectChain()` to hear further effects added.

# Comments

The `//` in the example above is a line comment, resulting in the `delay` function being ignored.
It is a handy way to quickly turn code on and off.
Try uncommenting this line by deleting `//` and refreshing the pattern.
You can also use the keyboard shortcut `cmd-/` to toggle comments on and off.

You might noticed that some comments in the REPL samples include some words starting with a "@", like `@by` or `@license`.
Those are just a convention to define some information about the music. We will talk about it in the [Music metadata](/learn/metadata) section.

# Strings

Ok, so what about the content inside the quotes (e.g. `"c a f e"`)?
In JavaScript, as in most programming languages, this content is referred to as being a [_string_](<https://en.wikipedia.org/wiki/String_(computer_science)>).
A string is simply a sequence of individual characters.
In TidalCycles, double quoted strings are used to write _patterns_ using the mini-notation, and you may hear the phrase _pattern string_ from time to time.
If you want to create a regular string and not a pattern, you can use single quotes, e.g. `'C minor'` will not be parsed as Mini Notation.

The good news is, that this covers most of the JavaScript syntax needed for Strudel!

<br />


---
title: Colors
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';
import Colors from '../../docs/Colors.jsx';

# Colors

<Colors />


---
title: Conditional Modifiers
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Conditional Modifiers

## lastOf

<JsDoc client:idle name="Pattern.lastOf" h={0} />

## firstOf

<JsDoc client:idle name="Pattern.firstOf" h={0} />

## when

<JsDoc client:idle name="Pattern.when" h={0} />

## chunk

<JsDoc client:idle name="Pattern.chunk" h={0} />

### chunkBack

<JsDoc client:idle name="Pattern.chunkBack" h={0} />

### fastChunk

<JsDoc client:idle name="Pattern.fastChunk" h={0} />

## arp

<JsDoc client:idle name="arp" h={0} />

## arpWith üß™

<JsDoc client:idle name="arpWith" h={0} />

## struct

<JsDoc client:idle name="Pattern#struct" h={0} />

## mask

<JsDoc client:idle name="Pattern#mask" h={0} />

## reset

<JsDoc client:idle name="Pattern#reset" h={0} />

## restart

<JsDoc client:idle name="Pattern#restart" h={0} />

## hush

<JsDoc client:idle name="Pattern#hush" h={0} />

## invert

<JsDoc client:idle name="invert" h={0} />

## pick

<JsDoc client:idle name="pick" h={0} />

## pickmod

<JsDoc client:idle name="pickmod" h={0} />

## pickF

<JsDoc client:idle name="pickF" h={0} />

## pickmodF

<JsDoc client:idle name="pickmodF" h={0} />

## pickRestart

<JsDoc client:idle name="pickRestart" h={0} />

## pickmodRestart

<JsDoc client:idle name="pickmodRestart" h={0} />

## pickReset

<JsDoc client:idle name="pickReset" h={0} />

## pickmodReset

<JsDoc client:idle name="pickmodReset" h={0} />

## inhabit

<JsDoc client:idle name="inhabit" h={0} />

## inhabitmod

<JsDoc client:idle name="inhabitmod" h={0} />

## squeeze

<JsDoc client:idle name="squeeze" h={0} />

After Conditional Modifiers, let's see what [Accumulation Modifiers](/learn/accumulation) have to offer.


---
title: Csound
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';
import Colors from '../../docs/Colors.jsx';

# Using CSound with Strudel

üß™ Strudel has experimental support for csound, using [@csound/browser](https://www.npmjs.com/package/@csound/browser).

## Importing .orc files

To use existing csound instruments, you can load and use an orc file from an URL like this:

<MiniRepl
  client:only="react"
  tune={`// livecode.orc by Steven Yi
await loadOrc('github:kunstmusik/csound-live-code/master/livecode.orc')
note("c a f e").csound('FM1')
`}
/>

Note that the above url uses the `github:` shortcut, which resolves to the raw file on github, but you can use any URL you like.

The awesome [`livecode.orc by Steven Yi`](https://github.com/kunstmusik/csound-live-code) comes packed with many sounds ready for use:

<MiniRepl
  client:only="react"
  tune={`// livecode.orc by Steven Yi
await loadOrc('github:kunstmusik/csound-live-code/master/livecode.orc')
note("c a f e").csound(cat(
"Sub1", // 	Substractive Synth, 3osc
"Sub2", // 	Subtractive Synth, two saws, fifth freq apart
"Sub3", // 	Subtractive Synth, three detuned saws, swells in
"Sub4", // 	Subtractive Synth, detuned square/saw, stabby. Nice as a lead in octave 2, nicely grungy in octave -2, -1
"Sub5", // 	Subtractive Synth, detuned square/triangle
"Sub6", // 	Subtractive Synth, saw, K35 filters
"Sub7", // 	Subtractive Synth, saw + tri, K35 filters
"Sub8", // 	Subtractive Synth, square + saw + tri, diode ladder filter
"SynBrass", // 	SynthBrass subtractive synth
"SynHarp", // 	Synth Harp subtracitve Synth
"SSaw", // 	SuperSaw sound using 9 bandlimited saws (3 sets of detuned saws at octaves)
"Mode1", // 	Modal Synthesis Instrument: Percussive/organ-y sound
"Plk", // 	Pluck sound using impulses, noise, and waveguides
"Organ1", // 	Wavetable Organ sound using additive synthesis
"Organ2", // 	Organ sound based on M1 Organ 2 patch
"Organ3", // 	Wavetable Organ using Flute 8' and Flute 4', wavetable based on Claribel Flute http://www.pykett.org.uk/the\_tonal\_structure\_of\_organ\_flutes.htm
"Bass", // 	Subtractive Bass sound
"ms20_bass", // 	MS20-style Bass Sound
"VoxHumana", // 	VoxHumana Patch
"FM1", // 	FM 3:1 C:M ratio, 2->0.025 index, nice for bass
"Noi", // 	Filtered noise, exponential envelope
"Wobble", // 	Wobble patched based on Jacob Joaquin's "Tempo-Synced Wobble Bass"
"Sine", // 	Simple Sine-wave instrument with exponential envelope
"Square", // 	Simple Square-wave instrument with exponential envelope
"Saw", // 	Simple Sawtooth-wave instrument with exponential envelope
"Squine1", // 	Squinewave Synth, 2 osc
"Form1", // 	Formant Synth, buzz source, soprano ah formants
"Mono", // 	Monophone synth using sawtooth wave and 4pole lpf. Use "start("Mono") to run the monosynth, then use MonoNote instrument to play the instrument.
"MonoNote", // 	Note playing instrument for Mono synth. Be careful to use this and not try to create multiple Mono instruments!
"Click", // 	Bandpass-filtered impulse glitchy click sound. p4 = center frequency (e.g., 3000, 6000)
"NoiSaw", // 	Highpass-filtered noise+saw sound. Use NoiSaw.cut channel to adjust cutoff.
"Clap", // 	Modified clap instrument by Istvan Varga (clap1.orc)
"BD", // 	Bass Drum - From Iain McCurdy's TR-808.csd
"SD", // 	Snare Drum - From Iain McCurdy's TR-808.csd
"OHH", // 	Open High Hat - From Iain McCurdy's TR-808.csd
"CHH", // 	Closed High Hat - From Iain McCurdy's TR-808.csd
"HiTom", // 	High Tom - From Iain McCurdy's TR-808.csd
"MidTom", // 	Mid Tom - From Iain McCurdy's TR-808.csd
"LowTom", // 	Low Tom - From Iain McCurdy's TR-808.csd
"Cymbal", // 	Cymbal - From Iain McCurdy's TR-808.csd
"Rimshot", // 	Rimshot - From Iain McCurdy's TR-808.csd
"Claves", // 	Claves - From Iain McCurdy's TR-808.csd
"Cowbell", // 	Cowbell - From Iain McCurdy's TR-808.csd
"Maraca", // 	Maraca - from Iain McCurdy's TR-808.csd
"HiConga", // 	High Conga - From Iain McCurdy's TR-808.csd
"MidConga", // 	Mid Conga - From Iain McCurdy's TR-808.csd
"LowConga", // 	Low Conga - From Iain McCurdy's TR-808.csd
))`}
/>

## Writing your own instruments

You can define your own instrument(s) with `loadCsound` like this:

<MiniRepl
  client:only="react"
tune={`await loadCsound\`
instr CoolSynth
    iduration = p3
    ifreq = p4
    igain = p5
    ioct = octcps(ifreq)

    kpwm = oscili(.05, 8)
    asig = vco2(igain, ifreq, 4, .5 + kpwm)
    asig += vco2(igain, ifreq * 2)

    idepth = 2
    acut = transegr:a(0, .005, 0, idepth, .06, -4.2, 0.001, .01, -4.2, 0) ; filter envelope
    asig = zdf_2pole(asig, cpsoct(ioct + acut + 2), 0.5)

    iattack = .01
    isustain = .5
    idecay = .1
    irelease = .1
    asig *= linsegr:a(0, iattack, 1, idecay, isustain, iduration, isustain, irelease, 0)

    out(asig, asig)

endin\`

"<0 2 [4 6](3,4,2) 3\*2>"
.off(1/4, add(2))
.off(1/2, add(6))
.scale('D minor')
.note()
.csound('CoolSynth')`}
/>

## Parameters

The `.csound` function sends the following p values:

|     |                                  |
| --- | -------------------------------- |
| p1  | instrument name e.g. `CoolSynth` |
| p2  | time offset, when it should play |
| p3  | the duration of the event / hap  |
| p4  | frequency in Hertz               |
| p5  | normalized `gain`, 0-1           |

There is an alternative `.csoundm` function with a different flavor:

|     |                                   |
| --- | --------------------------------- |
| p4  | midi key number, unrounded, 0-127 |
| p5  | midi velocity, 0-127              |

In both cases, p4 is derived from the value of `freq` or `note`.

## Limitations / Future Plans

Apart from the above listed p values, no other parameter can be patterned so far.
This also means that [audio effects](/learn/effects/) will not work.
In the future, the integration could be improved by passing all patterned control parameters to the csound instrument.
This could work by a unique [channel](https://kunstmusik.github.io/icsc2022-csound-web/tutorial2-interacting-with-csound/#step-4---writing-continuous-data-channels)
for each value. Channels could be read [like this](https://github.com/csound/csound/blob/master/Android/CsoundForAndroid/CsoundAndroidExamples/src/main/res/raw/multitouch_xy.csd).
Also, it might make sense to have a standard library of csound instruments for strudel's effects.

Now, let's dive into the [Functional JavaScript API](/functions/intro)


---
title: Device Motion
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';
import DeviceMotion from '@strudel/motion/docs/devicemotion.mdx';

<DeviceMotion />


---
title: Audio effects
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Audio Effects

Whether you're using a synth or a sample, you can apply any of the following built-in audio effects.
As you might suspect, the effects can be chained together, and they accept a pattern string as their argument.

# Signal chain

<img src="/img/strudel-signal-flow.png"></img>

The signal chain in Strudel is as follows:

- An sound-generating event is triggered by a pattern
  - This has a start time and a duration, which is usually
    controlled by the note length and ADSR parameters
  - If we exceed the max polyphony, old sounds begin to die off
  - Muted sounds (one whose `s` value is `-`, `~`, or `_`) are skipped
- A sound is produced (through, say, a sample or an oscillator)
  - This is where detune-based effects (like `detune`, `penv`, etc. occur)
- The following will occur _in order_ and only if they've been called in the pattern. Note that all of these are
  single use effects, meaning that multiple occurrences of them in a pattern will simply override the values
  (e.g. you can't do `s("bd").lpf(100).distort(2).lpf(800)` to lowpass, distort, and then lowpass
  again)
  - Phase vocoder (`stretch`)
  - Gain is applied (`gain`)
    - This is where the main (volume) ADSR happens
  - A lowpass filter (`lpf`)
  - A highpass filter (`hpf`)
  - A bandpass filter (`bandpass`)
  - A vowel filter (`vowel`)
  - Sample rate reduction (`coarse`)
  - Bit crushing (`crush`)
  - Waveshape distortion (`shape`)
  - Normal distortion (`distort`)
  - Tremolo (`tremolo`)
  - Compressor (`compressor`)
  - Panning (`pan`)
  - Phaser (`phaser`)
  - Postgain (`post`)
- The sound is then split into multiple destinations
  - Dry output (amount controlled by `dry` parameter)
  - The sends
    - Analyzers
      - These are used for tooling like `scope` and `spectrum` and their setup usually happens behind the scenes
    - Delay (amount controlled by `delay` parameter)
    - Reverb (amount controlled by `room` parameter)
- The dry output, delay, and reverb are joined into what is called the "orbit" of the pattern (see more in the section below)
  - The `duck` effect affects the volume of all signals in the orbit
  - The orbit is then sent to the mixer

## Orbits

Orbits are the way in which outputs are handled in Strudel. They also prescribe which delay and reverb to associate with the dry signal.
By default, all orbits are mixed down to channels `1` and `2` in stereo, however with the "Multi Channel Orbits" setting
(under Settings at the right) you can use them as individual 2 channel stereo outs (orbit `i` will be mapped to
to channels `2i` and `2i + 1`). You can then use routers like Blackhole 16 to retrieve and record all of the channels in a DAW for later processing.

The default orbit is `1` and it is set with `orbit`. You may send a sound to multiple orbits via mininotation

<MiniRepl client:visible tune={`s("white").orbit("2,3,4").gain(0.2)`} />

but please be careful as this will create three copies of the sound behind the scenes, meaning that if they are mixed
down to a single output, they will triple the volume. We've reduced the gain here to save your ears.

‚ö†Ô∏è There is only one delay and reverb per orbit, so please be aware that if you attempt to change the parameters on two
patterns pointing to the same orbit, it can lead to unpredictable results. Compare, for example, this pretty pluck
with a large reverb:

<MiniRepl
  client:visible
  tune={`
$: s("triangle*4").decay(0.5).n(irand(12)).scale('C minor')
  .room(1).roomsize(10)`}
/>

versus the same pluck with a muted kick drum coming in and overwriting the `roomsize` value:

<MiniRepl
  client:visible
  tune={`
$: s("triangle*4").decay(0.5).n(irand(12)).scale('C minor')
  .room(1).roomsize(10)

$: s("bd\*4").room(0.01).roomsize(0.01).postgain(0)`}
/>

This is due to them sharing the same orbit: the default of `1`. It can be corrected simply by updating the orbits to be
distinct:

<MiniRepl
  client:visible
  tune={`
$: s("triangle*4").decay(0.5).n(irand(12)).scale('C minor')
  .room(1).roomsize(10).orbit(2)

$: s("bd\*4").room(0.01).roomsize(0.01).postgain(0)`}
/>

## Continuous changes

As all of the above is triggered by a _sound occurring_, it is often the case that parameters may not be
modified continuously in time. For example,

<MiniRepl
  client:visible
  tune={`
s("supersaw").lpf(tri.range(100, 5000).slow(2))`}
/>

Will not produce a continually LFO'd low-pass filter due to the `tri` only being sampled every time the note hits
(in this case the default of once per cycle). You can fake it by introducing more sound-generating events, e.g.:

<MiniRepl
  client:visible
  tune={`
s("supersaw").seg(16).lpf(tri.range(100, 5000).slow(2))`}
/>

Some parameters _do_ induce continuous variations in time, though:

- The ADSR curve (governed by `attack`, `sustain`, `decay`, `release`)
- The pitch envelope curve (governed by `penv` and its associated ADSR)
- The FM curve (`fmenv`)
- The filter envelopes (`lpenv`, `hpenv`, `bpenv`)
- Tremolo (`tremolo`)
- Phaser (`phaser`)
- Vibrato (`vib`)
- Ducking (`duckorbit`)

# Filters

Filters are an essential building block of [subtractive synthesis](https://en.wikipedia.org/wiki/Subtractive_synthesis).
Strudel comes with 3 types of filters:

- low-pass filter: low frequencies may _pass_, high frequencies are cut off
- high-pass filter: high frequencies may _pass_, low frequencies are cut off
- band-pass filters: only a frequency band may _pass_, low and high frequencies around are cut off

Each filter has 2 parameters:

- cutoff: the frequency at which the filter starts to work. e.g. a low-pass filter with a cutoff of 1000Hz allows frequencies below 1000Hz to pass.
- q-value: Controls the resonance of the filter. Higher values sound more aggressive. Also see [Q-Factor](https://en.wikipedia.org/wiki/Q_factor)

## lpf

<JsDoc client:idle name="lpf" h={0} />

## lpq

<JsDoc client:idle name="lpq" h={0} />

## hpf

<JsDoc client:idle name="hpf" h={0} />

## hpq

<JsDoc client:idle name="hpq" h={0} />

## bpf

<JsDoc client:idle name="bpf" h={0} />

## bpq

<JsDoc client:idle name="bpq" h={0} />

## ftype

<JsDoc client:idle name="ftype" h={0} />

## vowel

<JsDoc client:idle name="vowel" h={0} />

# Amplitude Modulation

Amplitude modulation changes the amplitude (gain) periodically over time.

## am

<JsDoc client:idle name="am" h={0} />

## tremolosync

<JsDoc client:idle name="tremolosync" h={0} />

## tremolodepth

<JsDoc client:idle name="tremolodepth" h={0} />

## tremoloskew

<JsDoc client:idle name="tremoloskew" h={0} />

## tremolophase

<JsDoc client:idle name="tremolophase" h={0} />

## tremoloshape

<JsDoc client:idle name="tremoloshape" h={0} />

# Amplitude Envelope

The amplitude [envelope](<https://en.wikipedia.org/wiki/Envelope_(music)>) controls the dynamic contour of a sound.
Strudel uses ADSR envelopes, which are probably the most common way to describe an envelope:

![ADSR](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/ADSR_parameter.svg/1920px-ADSR_parameter.svg.png)

[image link](https://commons.wikimedia.org/wiki/File:ADSR_parameter.svg)

## attack

<JsDoc client:idle name="attack" h={0} />

## decay

<JsDoc client:idle name="decay" h={0} />

## sustain

<JsDoc client:idle name="sustain" h={0} />

## release

<JsDoc client:idle name="release" h={0} />

## adsr

<JsDoc client:idle name="adsr" h={0} />

# Filter Envelope

Each filter can receive an additional filter envelope controlling the cutoff value dynamically. It uses an ADSR envelope similar to the one used for amplitude. There is an additional parameter to control the depth of the filter modulation: `lpenv`|`hpenv`|`bpenv`. This allows you to play subtle or huge filter modulations just the same by only increasing or decreasing the depth.

<MiniRepl
  client:idle
  tune={`note("[c eb g <f bb>](3,8,<0 1>)".sub(12))
  .s("<sawtooth>/64")
  .lpf(sine.range(300,2000).slow(16))
  .lpa(0.005)
  .lpd(perlin.range(.02,.2))
  .lps(perlin.range(0,.5).slow(3))
  .lpq(sine.range(2,10).slow(32))
  .release(.5)
  .lpenv(perlin.range(1,8).slow(2))
  .ftype('24db')
  .room(1)
  .juxBy(.5,rev)
  .sometimes(add(note(12)))
  .stack(s("bd*2").bank('RolandTR909'))
  .gain(.5).fast(2)`}
/>

There is one filter envelope for each filter type and thus one set of envelope filter parameters preceded either by `lp`, `hp` or `bp`:

- `lpattack`, `lpdecay`, `lpsustain`, `lprelease`, `lpenv`: filter envelope for the lowpass filter.
  - alternatively: `lpa`, `lpd`, `lps`, `lpr` and `lpe`.
- `hpattack`, `hpdecay`, `hpsustain`, `hprelease`, `hpenv`: filter envelope for the highpass filter.
  - alternatively: `hpa`, `hpd`, `hps`, `hpr` and `hpe`.
- `bpattack`, `bpdecay`, `bpsustain`, `bprelease`, `bpenv`: filter envelope for the bandpass filter.
  - alternatively: `bpa`, `bpd`, `bps`, `bpr` and `bpe`.

## lpattack

<JsDoc client:idle name="lpattack" h={0} />

## lpdecay

<JsDoc client:idle name="lpdecay" h={0} />

## lpsustain

<JsDoc client:idle name="lpsustain" h={0} />

## lprelease

<JsDoc client:idle name="lprelease" h={0} />

## lpenv

<JsDoc client:idle name="lpenv" h={0} />

# Pitch Envelope

You can also control the pitch with envelopes!
Pitch envelopes can breathe life into static sounds:

<MiniRepl
  client:idle
  tune={`n("<-4,0 5 2 1>*<2!3 4>")
  .scale("<C F>/8:pentatonic")
  .s("gm_electric_guitar_jazz")
  .penv("<.5 0 7 -2>*2").vib("4:.1")
  .phaser(2).delay(.25).room(.3)
  .size(4).fast(1.5)`}
/>

You also create some lovely chiptune-style sounds:

<MiniRepl
  client:idle
  tune={`n(run("<4 8>/16")).jux(rev)
.chord("<C^7 <Db^7 Fm7>>")
.dict('ireal')
.voicing().add(note("<0 1>/8"))
.dec(.1).room(.2)
.segment("<4 [2 8]>")
.penv("<0 <2 -2>>").patt(.02).fast(2)`}
/>

Let's break down all pitch envelope controls:

## pattack

<JsDoc client:idle name="pattack" h={0} />

## pdecay

<JsDoc client:idle name="pdecay" h={0} />

## prelease

<JsDoc client:idle name="prelease" h={0} />

## penv

<JsDoc client:idle name="penv" h={0} />

## pcurve

<JsDoc client:idle name="pcurve" h={0} />

## panchor

<JsDoc client:idle name="panchor" h={0} />

# Dynamics

## gain

<JsDoc client:idle name="gain" h={0} />

## velocity

<JsDoc client:idle name="velocity" h={0} />

## compressor

<JsDoc client:idle name="compressor" h={0} />

## postgain

<JsDoc client:idle name="postgain" h={0} />

## xfade

<JsDoc client:idle name="xfade" h={0} />

# Panning

## jux

<JsDoc client:idle name="jux" h={0} />

## juxBy

<JsDoc client:idle name="juxBy" h={0} />

## pan

<JsDoc client:idle name="pan" h={0} />

# Waveshaping

## coarse

<JsDoc client:idle name="coarse" h={0} />

## crush

<JsDoc client:idle name="crush" h={0} />

## distort

<JsDoc client:idle name="distort" h={0} />

# Global Effects

## Local vs Global Effects

While the above listed "local" effects will always create a separate effects chain for each event,
global effects use the same chain for all events of the same orbit:

## orbit

<JsDoc client:idle name="orbit" h={0} />

## Delay

### delay

<JsDoc client:idle name="delay" h={0} />

### delaytime

<JsDoc client:idle name="delaytime" h={0} />

### delayfeedback

<JsDoc client:idle name="delayfeedback" h={0} />

## Reverb

### room

<JsDoc client:idle name="room" h={0} />

### roomsize

<JsDoc client:idle name="roomsize" h={0} />

### roomfade

<JsDoc client:idle name="roomfade" h={0} />

### roomlp

<JsDoc client:idle name="roomlp" h={0} />

### roomdim

<JsDoc client:idle name="roomdim" h={0} />

### iresponse

<JsDoc client:idle name="iresponse" h={0} />

## Phaser

### phaser

<JsDoc client:idle name="phaser" h={0} />

### phaserdepth

<JsDoc client:idle name="phaserdepth" h={0} />

### phasercenter

<JsDoc client:idle name="phasercenter" h={0} />

### phasersweep

<JsDoc client:idle name="phasersweep" h={0} />

## Duck

### duckorbit

<JsDoc client:idle name="duckorbit" h={0} />

### duckattack

<JsDoc client:idle name="duckattack" h={0} />

### duckdepth

<JsDoc client:idle name="duckdepth" h={0} />

Next, we'll look at input / output via [MIDI, OSC and other methods](/learn/input-output).


---
title: Creating Patterns
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Creating Patterns

The following functions will return a pattern.
These are the equivalents used by the Mini Notation:

| function                       | mini             |
| ------------------------------ | ---------------- |
| `cat(x, y)`                    | `"<x y>"`        |
| `seq(x, y)`                    | `"x y"`          |
| `stack(x, y)`                  | `"x,y"`          |
| `stepcat([3,x],[2,y])`         | `"x@3 y@2"`      |
| `polymeter([a, b, c], [x, y])` | `"{a b c, x y}"` |
| `polymeterSteps(2, x, y, z)`   | `"{x y z}%2"`    |
| `silence`                      | `"~"`            |

## cat

<JsDoc client:idle name="cat" h={0} />

## seq

<JsDoc client:idle name="seq" h={0} />

## stack

<JsDoc client:idle name="stack" h={0} />

## stepcat

<JsDoc client:idle name="stepcat" h={0} />

## arrange

<JsDoc client:idle name="arrange" h={0} />

## polymeter

<JsDoc client:idle name="polymeter" h={0} />

## polymeterSteps

<JsDoc client:idle name="polymeterSteps" h={0} />

## silence

<JsDoc client:idle name="silence" h={0} />

## run

<JsDoc client:idle name="run" h={0} />

## binary

<JsDoc client:idle name="binary" h={0} />

## binaryN

<JsDoc client:idle name="binaryN" h={0} />

After Pattern Constructors, let's see what [Time Modifiers](/learn/time-modifiers) are available.


---
title: Frequently Asked Questions
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Frequently Asked Questions

This page contains frequently asked questions, with answers. Usually, the topic is explained in more detail in a section which is linked in the answer.

## Is Strudel/Tidal free?

Yes - there is no charge, this is a collective open source project, and the music you make with it is your own. However if you can, please make a one-off or regular donation to our [opencollective fund](https://opencollective.com/tidalcycles), that supports the software and cultural development of Strudel and other Uzu languages.

While there is no charge there are some caveats, e.g.:

- the source code must stay free, i.e. you cannot distribute strudel or tidal as part of projects with incompatible licenses - see the [license](https://www.gnu.org/licenses/agpl-3.0.en.html) for details.
- the contributed examples and tracks are also separately licensed, and must not e.g. be used to train AI models without permission.

## How do I try out the latest features?

The main, stable strudel website is [strudel.cc](https://strudel.cc/). There is also [warm.strudel.cc](https://warm.strudel.cc), known as "warm strudel", which has the latest development features. You might find warm strudel has bug fixes and features that the main website doesn't, but it will often be less stable and probably not suitable for important performances.

Alternatively, you can run strudel locally to try out the latest features. You can find development-oriented [instructions for that here](https://codeberg.org/uzu/strudel/src/branch/main/CONTRIBUTING.md#project-setup).

You can see the [latest changes here](https://codeberg.org/uzu/strudel/pulls?q=&type=all&sort=recentupdate&state=closed&labels=&milestone=0&project=0&assignee=0&poster=0), as 'pull requests'.

## How to record or export audio?

Strudel is not a digital audio workstation and does not operate following the same principles shared by most traditional audio softwares. However, there are multiple ways to record the audio -- and video -- output of Strudel:

- Use the 'export' tab to render and download as an audio file.
- capture the raw stereo signal coming out of your web browser. You will need an external audio editor/DAW such as Reaper/Audacity/Ardour, etc.
- use the alternative SuperDirt audio engine. Read [this page](/learn/input-output/#oscsuperdirtstrudeldirt) to know more about it.
- capture the audio/video stream using a capture tool such as [OBS](https://obsproject.com/fr), which is designed for live streaming, but also works very well for recording.
- don't record anything and code it again in front of your friends.

## Can I use strudel with my IDE?

Yes you can. There are experimental modes, made by community members, for several IDEs such as:

- VS Code: [Strudel VS](https://marketplace.visualstudio.com/items?itemName=cmillsdev.strudelvs): an experimental mode for Microsoft VSCode. A revived version of [TidalStrudel](https://marketplace.visualstudio.com/items?itemName=roipoussiere.tidal-strudel), which is defunct.
- nvim: [strudel.nvim](https://github.com/gruvw/strudel.nvim)

## How can I use my own samples?

There are multiple ways to load your sample collection. Some methods are good for quick experimentation, some others are good to share your audio collection with other musicians:

- Import folders [from the interface](/learn/samples/#from-disk-via-import-sounds-folder). These are stored locally in your web browser, and not uploaded.
- Serve a folder of samples locally using the [strudel 'sampler' commandline tool](https://strudel.cc/learn/samples/#from-disk-via-strudelsampler). This can be most reliable method, but requires [nodejs](https://nodejs.org) to be installed.
- Host your sound library online on the web and [load them from an URL](/learn/samples/#loading-custom-samples)

## Can I use Strudel with AI/LLM tools?

You are free to do what you like with Strudel, within the terms of the free/open source AGPLv3 license.
However as a community we are interested in exploring human creativity. AI is _way_ over-hyped right now,
including by people with very shady motives. Many in the community are very wary of people training models
on their tunes that they've poured their love into. So please keep discussion and questions around AI and
LLMs to channels dedicated to the topic and be fully respectful of other people's work.

Furthermore, tools like ChatGPT generally give wrong answers. Please don't ask the community to fix those
answers for you, as generally they will be timewasting nonsense.

Human questions are always welcome!

## Where can I download loads of patterns to train my LLM?

You cannot, as there is no such place. For details regarding our stance towards AI/LLM, see [above](/learn/faq/#can-i-use-strudel-with-aillm-tools)

## How to run offline?

Strudel works offline just fine! There are multiple techniques for this, see [this explanation](learn/pwa/#using-strudel-offline).

## How to change tempo? How do I translate BPM to cpm?

Strudel works in cycles, rather than beats, but if you assume a certain number of beats per cycle, you can convert between them.

For example, if you have your tempo in beats per minute and use 4 beats per cycle (e.g. if your track is in 4/4ths) then you can do `setcpm(BPM/4)`
where BPM is your beats per minute.

If you have a different number of beats per bar or are using more or less beats per cycle (e.g. If you want to put only half a bar or
two bars into one cycle), adjust accordingly.

## Where can I see all the functions?

If you pop open the sidetab of strudel.cc (small white < on the right hand side), there is a tab "reference" which lists all the functions of strudel.

## Where can I see all the samples and synths?

If you pop open the sidetab of strudel.cc (small white < on the right hand side), there is a tab "sounds" which lists all the drum machines, samples and synths currently loaded.

## How do I use this exactly like a DAW?

Strudel has different design aims for a DAW, and so treating it like one will likely be frustrating. DAWs are geared towards
sequencing notes over time in predictable ways, whereas Strudel and similar Uzu languages are geared towards combining and
transforming patterns in ways that can be hard to predict.

If you want to emulate the functionality of a DAW in Strudel, you'll have to identify the operations
executed by the DAW (sequencing, repeating, applying filters and envelopes) and write code that is equivalent to these
operations. For example in Strudel, the 'arrange' and 'pick' methods are useful for sequencing patterns over time (see question on these later in this document).

You might still find that the typical DAW workflow is not really adapted to live coding because, despite
both being ways of making music on the computer, they are two very different tools. You could then adapt your way of proceeding
to the medium of code, which might mean leaving more place to serendipity and writing code that you don't predict the output of.

## Why doesn't everyone just use a DAW?

There is no easy answer to this question. Here are some thoughts:

- Live coding tools such as Strudel are excellent for improvising music and visuals using a computer. DAWs are valuable and robust companions for other activities such as producing, mastering and mixing audio, among other usages. Using a tool does not exclude from using any another tool, just build a toolbox.

- Live coding has developed over decades as a distinct creative practice. For example, live coding artists like to show their screens while playing in front of an audience. It is an essential part of what they do, of the way they share their activity with everybody.

- Code is a human language, it is made for other humans to read it. You can read the code and enjoy the music too. It has meaning, value, and there might even be something poetic/important about it! - Strudel is free and open source, you can inspect the code, reshape it, contribute to it if you can/want. It is not opaque and this matters for many people. There is no black box, no obscure abstractions, no business model, no user tracking or hidden features. We need open tools in the arts! - Live coders don't all shy away from using DAWs. Many use them all of the time, especially when it makes their life easier for... live coding!

- Code is an artistic material like any other. There is something valuable in the process of making music through code. More generally speaking, it is nice to tackle creative problems through the use of a programming language: creative thinking, building up your own solutions, DIY approach to music-making, unexpected outcome of algorithms, funny human errors, etc.

- There are pianos and trumpets in your DAW: why do people continue playing the piano or the trumpet? Think of live coding tools as instruments that you activate through the act of programming.

## How can I interface Strudel with my favorite music software? What can I do with it?

Strudel can send [MIDI and OSC](/learn/input-output/), which are protocols for communicating musical information.

Other music software (or hardware!) can then listen to these messages and process them according to its capabilities.

A simple example would be to send livecoded audio to a DAW like Ardour on different tracks and then use it to mix them.

You could also send the MIDI of a sequenced pattern to Musescore and then have it transcribe your livecoded work as a musical score.

You could also send MIDI to your hardware synths, if you like their sound.

## How do I use this in my closed source webgame or other software?

You don't. You need to license your game to a free/open source license fulfill the [AGPLv3 license](https://codeberg.org/uzu/strudel/src/branch/main/LICENSE) Strudel is distributed under.

## How to play different patterns simultaneously?

Using the $ operator, several patterns can be played at once:

<MiniRepl
  client:idle
  tune={`$: s("bd*4").bank("tr707")
$: s("- sd").bank("tr909")`}
/>

See also [stack](intro/#combining-patterns)

## Is it possible to mute a pattern?

With an additional underscore, a pattern can be muted.

<MiniRepl
  client:idle
  tune={`$: s("bd*4").bank("tr707")
_$: s("- sd").bank("tr909")`}
/>

See also [hush](/learn/conditional-modifiers/#hush)

## How can I arrange in Strudel using `mask`?

With mini-notation, using the `<>` and `!` operators, you can try something like

```
.mask("<0!24 1!40>")
```

It mutes a pattern for 24 cycles and plays it for 40. You would gain 64 cycles total, a multiple of 2/4/8 commonly used in western music.

If each cycle is a bar, as a starting point, you could write a mask like that for any pattern:

```
.mask("<0!16 0!16 0!16 0!16 0!16 0!10>")
```

It mutes it throughout.

For arranging, you could add the same mask to each part and replace some zeroes with ones in your different masks to make parts play.

If you use `.mask()` on different patterns mess up your counting, then patterns do not align anymore.
On the other hand, doing that on purpose is one of the things that could be considered a strength of tidalcycles and Strudel.
You can make things quite lively and more organic with a little (controlled) interference, according to your own taste.
And you are free to arrange in cycles like 3, 6 or 9 too.

To modify everything at once, you could try all and when, for example:

```
all(x=>x.when("<0!7 1>", x=>x.lpf(saw.range(200, 2000))))
```

This would lowpass filter sweep everything every 8 cycles.

## How can I arrange in Strudel using `arrange` or `pick`?

Take [Pachelbel's Canon in D](https://en.wikipedia.org/wiki/Pachelbel%27s_Canon#Analysis) as an example which has 4 voices (one cello and 3 violins) which have repeating patterns, as seen in the link above.

The following snipped defines the patterns as constants which can then be used for the different voices. `arrange` takes multiple arguments, which are each a number of cycles and a pattern which is played for the number of cycles, wrapped in `[]` If the pattern is shorter than the number, it is repeated.

<MiniRepl client:idle tune={`const cello = note(
  "<[d3 a2 b2 f#2] [g2 d3 g2 a2]>")
  .color("grey").sound("gm_tremolo_strings:3")
 const violin_p1 = note(
  "<[f#5 e5 d5 c#5] [b4 a4 b4 c#5]>")
  .color("blue")
 const violin_p2 = note(
  "<[d5 c#5 b4 a4] [ g4 f#4 g4 f#4]>")
 .color("green")
 const violin_p3 = note(
  "<[d4 f#4 a4 g4 f#4 d4 f#4 e4] [d4 b3 d4 a4 g4 b4 a4 g4]>")
  .color("purple")
 const violin_p4 = note(
  "<[f#4 d4 e4 c#5 d5 f#5 a5 a4] [b4 g4 a4 f#4 d4 d5 [d5@3 c#5]@2]>")
  .color("red")

cello$: arrange(
  [2, silence],
  [18,cello])
 violin1$: arrange(
[4,silence],
[2,violin_p1], [2,violin_p2],
[2,violin_p3], [2,violin_p4],
[2,violin_p1], [2,violin_p2],
[2,violin_p3], [2,violin_p4]
).sound("gm_tremolo_strings:0")
violin2$: arrange(
  [6,silence], [2,violin_p1], 
  [2,violin_p2], [2,violin_p3], 
  [2,violin_p4], [2,violin_p1], 
  [2,violin_p2], [2,violin_p3] 
  ).sound("gm_tremolo_strings:1")
 violin3$: arrange(
[8,silence],
[2,violin_p1], [2,violin_p2],
[2,violin_p3], [2,violin_p4],
[2,violin_p1], [2,violin_p2]
).sound("gm_tremolo_strings:2")

    all(x => x.release(.2))

`} />

Alternatively, you can also put the different patterns for the violins into one single array (`const violins = [violin_p1, violin_p2, violin_p3, violin_p4]`) and use a pattern as an index to `pick` the nth element of that array. This replaces the voices defined above. Here you use `0@2` to specifiy that the first item (i.e. with index `0`) is played for `2` cycles.

`pick` has better highlighting than `arrange`:

<MiniRepl client:idle tune={`const cello = note(
  "<[d3 a2 b2 f#2] [g2 d3 g2 a2]>")
  .color("grey").sound("gm_tremolo_strings:3")
 const violin_p1 = note(
  "<[f#5 e5 d5 c#5] [b4 a4 b4 c#5]>")
  .color("blue")
 const violin_p2 = note(
  "<[d5 c#5 b4 a4] [ g4 f#4 g4 f#4]>")
 .color("green")
 const violin_p3 = note(
  "<[d4 f#4 a4 g4 f#4 d4 f#4 e4] [d4 b3 d4 a4 g4 b4 a4 g4]>")
  .color("purple")
 const violin_p4 = note(
  "<[f#4 d4 e4 c#5 d5 f#5 a5 a4] [b4 g4 a4 f#4 d4 d5 [d5@3 c#5]@2]>")
  .color("red")

const violins = [violin_p1, violin_p2, violin_p3, violin_p4]

cello$: "<~@2 0@18>".pick([cello])
violin1$: "<~@4 0@2 1@2 2@2 3@2 0@2 1@2 2@2 3@2>".pick(violins)
.sound("gm_tremolo_strings:0")
violin2$: "<~@6 0@2 1@2 2@2 3@2 0@2 1@2 2@2>".pick(violins)
.sound("gm_tremolo_strings:1")
violin3$: "<~@8 0@2 1@2 2@2 3@2 0@2 1@2 >".pick(violins)
.sound("gm_tremolo_strings:2")
all(x => x.release(.2))
`} />

The `pick` method also works with jsons which have named elements, which makes it easier to read, see the [here](/learn/conditional-modifiers/#pick). `pickRestart` restarts the pattern upon picking it which can make a difference if the duration of the pick indexes doesn't line up with the patterns which are picked - which is not the case here.

Try adding `.punchcard()` after the `release(.2)` for a visualization.

## I saw Switch Angel using functions which I cannot find in the reference (e.g. `trancegate`). How do I make it work?

Methods like `trancegate()`, `rlpf()` and `acidenv()` are currently not pattern methods which come natively with strudel.

They are part of a script/prebake for strudel which was written by Switch Angel and published [here](https://github.com/switchangel/strudel-scripts)

You can find the instructions how to use that script in the readme.md there.

## Is there difference between `n` and `note`?

They are not aliases of each other, in contrast to `s` and `sound`.

The method `note` is used to reference a certain note (either as its name, such as `c` or `b2` or the midi number `69`, for example `note("c3 e3 g3")`).

On the other hand, `n` is a way to reference the nth index of something. This something can be a scale (eg `n("0 2 4").scale("C:major")`) , but it can also be a particular note in a chord (see https://strudel.cc/recipes/recipes/#arpeggios for an example) .

The method `n` can also be used for something completely unrelated to notes, in particular the nth sample from a sample map `s("hh*8").bank("RolandTR909").n("0 1 2 3")`.

<MiniRepl
  client:idle
  tune={`
        n("<[0 1 2 3@3 -@2] [3 2 1 0@3 -@2] >")
        .scale("A:minor:pentatonic")
        .s("gm_acoustic_guitar_steel").n("<0 1 2 3>/2")`}
/>

Note that `n` is not the only way that functions use indices, some take numbered patterns instead.

## Is there a cheat sheet for all symbols?

Yes!

```
'   marks start and end of strings, is different from "
"   marks start and end of single line patterns in mini notation, is different from '
`   marks start and end of patterns with line breaks in mini notation, is different from '
[]  used for patterns in mini notation, each item in it has the same length
<>  used for patterns, alternates between items each cycle
{}  historically used for polyrhythmic patterns. {a b c}%4 is the same as <a b c>*4.
@3  elongates the item by a factor of 3 (other numbers work too, even non-integer, but for numbers between 0 and 1 you need a leading zero like this: @0.5)
@   after an item: elongates the item once (multiple @ work too c @ @ is the same as c@3)
_   after an item: also elongates an item once (multiple _ work too c _ _ is the same as c@3), see below for a different usage.
.   this divides equal parts of a pattern and is called a foot. Can be used instead of [] like this: "1 6 7 8 . 2 . 3 . 4" is the same as "[1 6 7 8] 2 3 4"
-   silence
~   also silence
x   not silence (for the use in struct, any non-silence symbol works there)
b   decrease by one semitone, i.e. flat, works for steps of scales, note names (but not midi numbers) and chord names
s   increase by one semitone, i.e. sharp, works for steps of scales, note names (but not midi numbers) but not chord names
#   increase by one semitone, i.e. sharp works for steps of scales, note names (but not midi numbers) and chord names
#   also used in mondo notation
*3  play the sample or pattern at thrice the speed, fast(3)
!3  play the sample or pattern three times
/2  play the sample or pattern at half speed, slow(2)
?   play the pattern sometimes
|   once per cycle, choose randomly a pattern of those separated by i.e. chooseCycles()
,   play all items separated by it at the same time, i.e. stack()
:   is used to separate multiple parameters, such as adsr(".1:.1:.5:.2"), this is is an operator which creates a list of these objects.
$:  at the start of a line, defines a member of the stack. is the only stack name that should occur multiple names
_   before a stack name: mutes the stack, i.e. hush(), for example _$: s("bd"), see above for a different usage.
```


---
title: Getting Started
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Welcome

Welcome to the Strudel documentation pages!

These pages will introduce you to [Strudel](https://strudel.cc/), a web-based [live coding](https://github.com/toplap/awesome-livecoding/) environment that implements the [Tidal Cycles](https://tidalcycles.org) algorithmic pattern language.

# What is Strudel?

[Strudel](https://strudel.cc/) is a version of [Tidal Cycles](https://tidalcycles.org) written in [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript), initiated by [Alex McLean](https://slab.org) and [Felix Roos](https://froos.cc/) in 2022.
Tidal Cycles, also known as Tidal, is a language for [algorithmic pattern](https://algorithmicpattern.org), and though it is most commonly used for [making music](https://tidalcycles.org/docs/showcase), it can be used for any kind of pattern making activity, including [weaving](https://www.youtube.com/watch?v=TfEmEsusXjU).

Tidal was first implemented as a library written in the [Haskell](https://www.haskell.org/) functional programming language, and by itself it does not make any sound.
To make sound, it has to be connected to a sound engine, and by default this is a [SuperCollider](https://supercollider.github.io/) plugin called [SuperDirt](https://github.com/musikinformatik/SuperDirt/).
As such, it can be difficult for first-time users to install both Tidal Cycles and SuperDirt, as there are many small details to get right.
Strudel however runs directly in your web browser, does not require any custom software installation, and can make sound all by itself.

# Strudel REPL and MiniREPL

The main place to actually make music with Strudel is the [Strudel REPL](https://strudel.cc/) ([what is a REPL?](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)), but in these pages you will also encounter interactive "MiniREPLs" where you can listen to and edit Strudel patterns.
Try clicking the play icon below:

<MiniRepl client:idle tune={`s("bd sd")`} punchcard />

Then edit the text so it reads `s("bd sd cp hh")` and click the refresh icon.
Congratulations, you have now live coded your first Strudel pattern!

With Strudel, you can expressively write dynamic music pieces.
You don't need to know JavaScript or Tidal Cycles to make music with Strudel.
This interactive tutorial will guide you through the basics of Strudel.

# Show me some demos!

To see and hear what Strudel can do, visit the [Strudel REPL](https://strudel.cc/) and click the Shuffle icon in the top menu bar.
You can get a feel for Strudel by browsing and editing these examples and clicking the Refresh icon to update.

You can also browse through the examples [here](/examples).

Alternatively, you can get a taste of what Strudel can do by clicking play on this track:

<MiniRepl
  client:idle
  tune={`samples({
  bd: ['bd/BT0AADA.wav','bd/BT0AAD0.wav','bd/BT0A0DA.wav','bd/BT0A0D3.wav','bd/BT0A0D0.wav','bd/BT0A0A7.wav'],
  sd: ['sd/rytm-01-classic.wav','sd/rytm-00-hard.wav'],
  hh: ['hh27/000_hh27closedhh.wav','hh/000_hh3closedhh.wav'],
}, 'github:tidalcycles/dirt-samples');
stack(
s("bd,[~ <sd!3 sd(3,4,2)>],hh*8") // drums
.speed(perlin.range(.7,.9)) // random sample speed variation
,"<a1 b1\*2 a1(3,8) e2>" // bassline
.off(1/8,x=>x.add(12).degradeBy(.5)) // random octave jumps
.add(perlin.range(0,.5)) // random pitch variation
.superimpose(add(.05)) // add second, slightly detuned voice
.note() // wrap in "note"
.decay(.15).sustain(0) // make each note of equal length
.s('sawtooth') // waveform
.gain(.4) // turn down
.cutoff(sine.slow(7).range(300,5000)) // automate cutoff
,"<Am7!3 <Em7 E7b13 Em7 Ebm7b5>>".voicings('lefthand') // chords
.superimpose(x=>x.add(.04)) // add second, slightly detuned voice
.add(perlin.range(0,.5)) // random pitch variation
.note() // wrap in "note"
.s('sawtooth') // waveform
.gain(.16) // turn down
.cutoff(500) // fixed cutoff
.attack(1) // slowly fade in
)
.slow(3/2)`}
/>

# Strudel is a work in progress üöß

Please note that this project is still in its experimental state.
In the future, parts of it might change significantly.
This tutorial is also far from complete.
You can contribute to it clicking 'Edit this page' in the top right, or by visiting the [Strudel GitHub page](https://codeberg.org/uzu/strudel/).

# What's next?

Head on over to the [Notes](/learn/notes) page.

<br />


---
title: Hydra
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Using Hydra inside Strudel

You can write [hydra](https://hydra.ojack.xyz/) code in strudel! All you have to do is to call `await initHydra()` at the top:

<MiniRepl
  client:only="react"
  tune={`await initHydra()
// licensed with CC BY-NC-SA 4.0 https://creativecommons.org/licenses/by-nc-sa/4.0/
// by Zach Krall
// http://zachkrall.online/

osc(10, 0.9, 300)
.color(0.9, 0.7, 0.8)
.diff(
osc(45, 0.3, 100)
.color(0.9, 0.9, 0.9)
.rotate(0.18)
.pixelate(12)
.kaleid()
)
.scrollX(10)
.colorama()
.luma()
.repeatX(4)
.repeatY(4)
.modulate(
osc(1, -0.9, 300)
)
.scale(2)
.out()

note("[a,c,e,<a4 ab4 g4 gb4>,b4]/2")
.s("sawtooth").vib(2)
.lpf(600).lpa(2).lpenv(6)
`}
/>

## H patterns

There is a special function `H` that allows you to use a pattern as an input to hydra:

<MiniRepl
  client:only="react"
  tune={`await initHydra()
let pattern = "3 4 5 [6 7]*2"
shape(H(pattern)).out(o0)
n(pattern).scale("A:minor").piano().room(1)
`}
/>

## detectAudio

To use hydra audio capture, call `initHydra` with `{detectAudio:true}` configuration param:

<MiniRepl
  client:only="react"
  tune={`await initHydra({detectAudio:true})
let pattern = "<3 4 5 [6 7]*2>"
shape(H(pattern)).repeat()
  .scrollY(
    ()=> a.fft[0]*.25
  )
  .add(src(o0).color(.71 ).scrollX(.005),.95)
.out(o0)
n(pattern).scale("A:minor").piano().room(1)
`}
/>

You might now be able to see this properly here: [open in REPL](/#YXdhaXQgaW5pdEh5ZHJhKCkKbGV0IHBhdHRlcm4gPSAiMyA0IDUgWzYgN10qMiIKc2hhcGUoSChwYXR0ZXJuKSkub3V0KG8wKQpuKHBhdHRlcm4pLnNjYWxlKCJBOm1pbm9yIikucGlhbm8oKS5yb29tKDEpIA%3D%3D)

Similar to `detectAudio`, all the [available hydra options](https://github.com/hydra-synth/hydra-synth#api) can be passed to `initHydra`.

## feedStrudel

Using the `feedStrudel` option, you can transform strudel visualizations with hydra:

<MiniRepl
  client:only="react"
  tune={`await initHydra({feedStrudel:1})
//
src(s0).kaleid(H("<4 5 6>"))
  .diff(osc(1,0.5,5))
  .modulateScale(osc(2,-0.25,1))
  .out()
//

$: s("bd*4,[hh:0:<.5 1>]*8,~ rim").bank("RolandTR909").speed(.9)

$: note("[<g1!3 <bb1 <f1 d1>>>]\*3").s("sawtooth")

.room(.75).sometimes(add(note(12))).clip(.3)
.lpa(.05).lpenv(-4).lpf(2000).lpq(8).ftype('24db')

all(x=>x.fft(4).scope({pos:0,smear:.95}))`}
/>


---
title: Input Devices
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

import Gamepad from '@strudel/gamepad/docs/gamepad.mdx';

# Input Devices

Strudel supports various input devices like Gamepads and MIDI controllers to manipulate patterns in real-time.

<Gamepad />


---
title: MIDI, OSC & MQTT
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# MIDI, OSC and MQTT

Normally, Strudel is used to pattern sound, using its own '[web audio](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)'-based synthesiser called [SuperDough](https://codeberg.org/uzu/strudel/src/branch/main/packages/superdough).

It is also possible to pattern other things with Strudel, such as software and hardware synthesisers with MIDI, other software using Open Sound Control/OSC (including the [SuperDirt](https://github.com/musikinformatik/SuperDirt/) synthesiser commonly used with Strudel's sibling [TidalCycles](https://tidalcycles.org/)), or the MQTT 'internet of things' protocol.

# MIDI

Strudel supports MIDI without any additional software (thanks to [webmidi](https://npmjs.com/package/webmidi)), just by adding methods to your pattern:

## midin(inputName?)

<JsDoc client:idle name="midin" h={0} />

## midikeys(inputName?)

<JsDoc client:idle name="midikeys" h={0} />

## midi(outputName?,options?)

Either connect a midi device or use the IAC Driver (Mac) or Midi Through Port (Linux) for internal midi messages.
If no outputName is given, it uses the first midi output it finds.

<MiniRepl
  client:idle
  tune={`
$: chord("<C^7 A7 Dm7 G7>").voicing().midi('IAC Driver')
`}
/>

In the console, you will see a log of the available MIDI devices as soon as you run the code,
e.g.

```
 `Midi connected! Using "Midi Through Port-0".`
```

The `.midi()` function accepts an options object with the following properties:

<MiniRepl
  client:idle
  tune={`$: note("d e c a f").midi('IAC Driver', { isController: true, midimap: 'default'})
`}
/>

<details>
<summary>Available Options</summary>

| Option       | Type          | Default   | Description                                                            |
| ------------ | ------------- | --------- | ---------------------------------------------------------------------- |
| isController | boolean       | false     | When true, disables sending note messages. Useful for MIDI controllers |
| latencyMs    | number        | 34        | Latency in milliseconds to align MIDI with audio engine                |
| noteOffsetMs | number        | 10        | Offset in milliseconds for note-off messages to prevent glitching      |
| midichannel  | number        | 1         | Default MIDI channel (1-16)                                            |
| velocity     | number        | 0.9       | Default note velocity (0-1)                                            |
| gain         | number        | 1         | Default gain multiplier for velocity (0-1)                             |
| midimap      | string        | 'default' | Name of MIDI mapping to use for control changes                        |
| midiport     | string/number | -         | MIDI device name or index                                              |

</details>

### midiport(outputName)

Selects the MIDI output device to use, pattern can be used to switch between devices.

```javascript
$: midiport('IAC Driver');
$: note('c a f e').midiport('<0 1 2 3>').midi();
```

<JsDoc client:idle name="midiport" h={0} />

## midichan(number)

Selects the MIDI channel to use. If not used, `.midi` will use channel 1 by default.

## midicmd(command)

`midicmd` sends MIDI system real-time messages to control timing and transport on MIDI devices.

It supports the following commands:

- `clock`/`midiClock` - Sends MIDI timing clock messages
- `start` - Sends MIDI start message
- `stop` - Sends MIDI stop message
- `continue` - Sends MIDI continue message

// You can control the clock with a pattern and ensure it starts in sync when the repl begins.
// Note: It might act unexpectedly if MIDI isn't set up initially.

<MiniRepl
  client:idle
  tune={`$:stack(
  midicmd("clock*48,<start stop>/2").midi('IAC Driver')
)`}
/>

## control, ccn && ccv

- `control` sends MIDI control change messages to your MIDI device.
- `ccn` sets the cc number. Depends on your synths midi mapping
- `ccv` sets the cc value. normalized from 0 to 1.

<MiniRepl client:idle tune={`note("c a f e").control([74, sine.slow(4)]).midi()`} />

<MiniRepl client:idle tune={`note("c a f e").ccn(74).ccv(sine.slow(4)).midi()`} />

In the above snippet, `ccn` is set to 74, which is the filter cutoff for many synths. `ccv` is controlled by a saw pattern.
Having everything in one pattern, the `ccv` pattern will be aligned to the note pattern, because the structure comes from the left by default.
But you can also control cc messages separately like this:

<MiniRepl
  client:idle
  tune={`$: note("c a f e").midi()
$: ccv(sine.segment(16).slow(4)).ccn(74).midi()`}
/>

Instead of setting `ccn` and `ccv` directly, you can also create mappings with `midimaps`:

## midimaps

<JsDoc client:idle name="midimaps" h={0} />

## defaultmidimap

<JsDoc client:idle name="defaultmidimap" h={0} />

## progNum (Program Change)

`progNum` sends MIDI program change messages to switch between different presets/patches on your MIDI device.
Program change values should be numbers between 0 and 127.

<MiniRepl client:idle tune={`// Switch between programs 0 and 1 every cycle
progNum("<0 1>").midi()

// Play notes while changing programs
note("c3 e3 g3").progNum("<0 1 2>").midi()`} />

Program change messages are useful for switching between different instrument sounds or presets during a performance.
The exact sound that each program number maps to depends on your MIDI device's configuration.

## sysex, sysexid && sysexdata (System Exclusive Message)

`sysex` sends MIDI System Exclusive (SysEx) messages to your MIDI device.
ysEx messages are device-specific commands that allow deeper control over synthesizer parameters.
The value should be an array of numbers between 0-255 representing the SysEx data bytes.

<MiniRepl
  client:idle
  tune={`// Send a simple SysEx message
let id = 0x43; //Yamaha
//let id = "0x00:0x20:0x32"; //Behringer ID can be an array of numbers
let data = "0x79:0x09:0x11:0x0A:0x00:0x00"; // Set NSX-39 voice to say "Aa"
$: note("c a f e").sysex(id, data).midi();
$: note("c a f e").sysexid(id).sysexdata(data).midi();`}
/>

The exact format of SysEx messages depends on your MIDI device's specification.
Consult your device's MIDI implementation guide for details on supported SysEx messages.

## midibend && miditouch

`midibend` sets MIDI pitch bend (-1 - 1)
`miditouch` sets MIDI key after touch (0-1)

<MiniRepl client:idle tune={`note("c a f e").midibend(sine.slow(4).range(-0.4,0.4)).midi()`} />

<MiniRepl client:idle tune={`note("c a f e").miditouch(sine.slow(4).range(0,1)).midi()`} />

# OSC/SuperDirt/StrudelDirt

In TidalCycles, sound is usually generated using [SuperDirt](https://github.com/musikinformatik/SuperDirt/), which runs inside SuperCollider. Strudel also supports using SuperDirt, although it requires installing some additional software.

There is also [StrudelDirt](https://github.com/daslyfe/StrudelDirt) which is SuperDirt with some optimisations for working with Strudel. (A longer term aim is to merge these optimisations back into mainline SuperDirt)

## Prequisites

To get SuperDirt to work with Strudel, you need to

1. install SuperCollider + sc3 plugins, see [Tidal Docs](https://tidalcycles.org/docs/) (Install Tidal) for more info.
2. install SuperDirt, or the [StrudelDirt](https://github.com/daslyfe/StrudelDirt) fork which is optimised for use with Strudel
3. install [node.js](https://nodejs.org/en/)
4. download [Strudel Repo](https://codeberg.org/uzu/strudel/) (or git clone, if you have git installed)
5. run `pnpm i` in the strudel directory
6. run `pnpm run osc` to start the osc server, which forwards OSC messages from Strudel REPL to SuperCollider

Now you're all set!

## Usage

1. Start SuperCollider, either using SuperCollider IDE or by running `sclang` in a terminal
2. Open the [Strudel REPL](https://strudel.cc/#cygiYmQgc2QiKS5vc2MoKQ%3D%3D)

...or test it here:

<MiniRepl client:only="react" tune={`s("bd sd").osc()`} />

If you now hear sound, congratulations! If not, you can get help on the [#strudel channel in the TidalCycles discord](https://discord.com/invite/HGEdXmRkzT).

Note: if you have the 'Audio Engine Target' in settings set to 'OSC', you do not need to add .osc() to the end of your pattern.

### Pattern.osc

<JsDoc client:idle name="Pattern.osc" h={0} />

## SuperDirt Params

Please refer to [Tidal Docs](https://tidalcycles.org/) for more info.

<br />

But can we use Strudel [offline](/learn/pwa)?

# MQTT

MQTT is a lightweight network protocol, designed for 'internet of things' devices. For use with strudel, you will
need access to an MQTT server known as a 'broker' configured to accept secure 'websocket' connections. You could
run one yourself (e.g. by running [mosquitto](https://mosquitto.org/)), although getting an SSL certificate that
your web browser will trust might be a bit tricky for those without systems administration experience.
Alternatively, you can use [a public broker](https://www.hivemq.com/mqtt/public-mqtt-broker/).

Strudel does not yet support receiving messages over MQTT, only sending them.

## Usage

The following example shows how to send a pattern to an MQTT broker:

<MiniRepl
  client:only="react"
  tune={`"hello world"
    .mqtt(undefined, // username (undefined for open/public servers)
          undefined, // password
          '/strudel-pattern', // mqtt 'topic'
          'wss://mqtt.eclipseprojects.io:443/mqtt', // MQTT server address
          'mystrudel', // MQTT client id - randomly generated if not supplied
          0 // latency / delay before sending messages (0 = no delay)
         )`}

/>

Other software can then receive the messages. For example using the [mosquitto](https://mosquitto.org/) commandline client tools:

```

> mosquitto_sub -h mqtt.eclipseprojects.io -p 1883 -t "/strudel-pattern"
> hello
> world
> hello
> world
> ...

```

Control patterns will be encoded as JSON, for example:

<MiniRepl
  client:only="react"
  tune={`sound("sax(3,8)").speed("2 3")
  .mqtt(undefined, // username (undefined for open/public servers)
        undefined, // password
        '/strudel-pattern', // mqtt 'topic'
        'wss://mqtt.eclipseprojects.io:443/mqtt', // MQTT server address
        'mystrudel', // MQTT client id - randomly generated if not supplied
        0 // latency / delay before sending messages (0 = no delay)
       )`}
/>

Will send messages like the following:

```

{"s":"sax","speed":2}
{"s":"sax","speed":2}
{"s":"sax","speed":3}
{"s":"sax","speed":2}
...

```

Libraries for receiving MQTT are available for many programming languages.

```

```


---
title: Music metadata
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Music metadata

You can optionally add some music metadata in your Strudel code, by using tags in code comments:

```js
// @title My Cool Song
// @by John Doe
// @license CC-BY-SA-4.0
```

Like other comments, those are ignored by Strudel, but it can be used by other tools to retrieve some information about the music.

## Alternative syntax

You can also use comment blocks:

```js
/*
@title My Cool Song
@by John Doe
@license CC-BY-SA-4.0
*/
```

Or define multiple tags in one line:

```js
// @title My Cool Song @by John Doe @license CC-BY-SA-4.0
```

The `title` tag has an alternative syntax using quotes (must be defined at the very begining):

```js
// "My Cool Song" @by John Doe
```

## Tags list

Available tags are:

- `@title`: music title
- `@by`: music author(s), separated by comma, eventually followed with a link in `<>` (ex: `@by John Doe <https://example.com>`)
- `@license`: music license(s), separated by comma. Each license should be specified by using the correct identifier in the [https://spdx.org/licenses/](SPDX License List). Example: CC-BY-SA-4.0. Unsure? [Choose a Creative Commons license here](https://creativecommons.org/choose/).
- `@details`: some additional information about the music
- `@url`: web page(s) related to the music (git repository, Soundcloud link, etc.)
- `@genre`: music genre(s) (pop, jazz, etc.)
- `@album`: music album name
- `@tag`: custom tag

Note to tool authors: _Never_ trust that a song has filled those fields with syntactically correct values; make sure your software is robust enough it doesn't break if it encounters bad values

## Multiple values

Some of them accepts several values, using the comma or new line separator, or duplicating the tag:

```js
/*
@by John Doe
    Jane Doe
@genre pop, jazz
@url https://example.com
@url https://example.org
*/
```

You can also add optional prefixes and use tags where you want:

```js
/*
song @by John Doe
samples @by Jane Doe
*/
...
note("a3 c#4 e4 a4") // @by Sandy Sue
```

## Multiline

If a tag doesn't accept a list, it can take multi-line values:

```js
/*
@details I wrote this song in February 19th, 2023.
         It was around midnight and I was lying on
         the sofa in the living room.
*/
```

# Searching meta-data in the online repl

Meta-data can be used in the search field of the patterns tab in the online repl.

For example to search for all patterns by a specific author use the search term

```
by: Ada L
```

or search for patterns with a specific genre like

```
genre: unicorns
```

Hint: If no meta-data property is provided in the search all patterns with a `@title`, `@by` or `@tag` matching the search term will be shown.


---
title: Mini Notation
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Mini-notation

Just like [Tidal Cycles](https://tidalcycles.org/), Strudel uses a so called "Mini-Notation", which is a custom language that is designed for writing rhythmic patterns using little amounts of text.

## Note

This page just explains the entirety of the Mini-Notation syntax.
If you are just getting started with Strudel, you can learn the basics of the Mini-Notation in a more practical manner in the [workshop](/workshop/first-sounds).
After that, you can come back here if you want to understand every little detail.

## Example

Before diving deeper into the details, here is a flavour of how the Mini-Notation looks like:

<MiniRepl
  client:idle
  tune={`note(\`<
[e5 [b4 c5] d5 [c5 b4]]
[a4 [a4 c5] e5 [d5 c5]]
[b4 [~ c5] d5 e5]
[c5 a4 a4 ~]
[[~ d5] [~ f5] a5 [g5 f5]]
[e5 [~ c5] e5 [d5 c5]]
[b4 [b4 c5] d5 e5]
[c5 a4 a4 ~]
,
[[e2 e3]*4]
[[a2 a3]*4]
[[g#2 g#3]*2 [e2 e3]*2]
[a2 a3 a2 a3 a2 a3 b1 c2]
[[d2 d3]*4]
[[c2 c3]*4]
[[b1 b2]*2 [e2 e3]*2]
[[a1 a2]*4]
>\`)`}
/>

## Mini Notation Format

The snippet above is enclosed in backticks (`), which allows you to write multi-line strings.

You can also use regular double quotes (`"`) for single line mini-notation, as we have done already.

If you do just want to get a regular string that is _not_ parsed as mini-notation, use single quotes (`'`).

## Sequences of events in a cycle

We can play more notes by separating them with spaces:

<MiniRepl client:idle tune={`note("c e g b")`} punchcard />

Here, those four notes are squashed into one cycle, so each note is a quarter second long.
Try adding or removing notes and notice how the tempo changes!

<MiniRepl client:idle tune={`note("c d e f g a b")`} punchcard />

Note that the overall duration of time does not change, and instead each note length decreases.
This is a key idea, as it illustrates the 'Cycle' in TidalCycles!

Each space-separated note in this sequence is an _event_.
The time duration of each event is based on the speed or tempo of the cycle, and how many events are present.
Taking the two examples above, we have four and eight events respectively, and since they have the same cycle duration, they each have to fit their events inside the same amount of time.

This is perhaps counter-intuitive if you are used to adding notes in a sequencer or piano roll and the overall length increasing.
But, it will begin to make sense as we go through more elements of mini-notation.

## Multiplication

A sequence can be sped up by multiplying it by a number using the asterisk symbol (`*`):

<MiniRepl client:idle tune={`note("[e5 b4 d5 c5]*2")`} punchcard />

The multiplication by two here means that the sequence will play twice per cycle.

Multiplications can also be decimal (`*2.75`):

<MiniRepl client:idle tune={`note("[e5 b4 d5 c5]*2.75")`} punchcard />

## Division

Contrary to multiplication, division can slow the sequence down by enclosing it in brackets and dividing it by a number (`/2`):

<MiniRepl client:idle tune={`note("[e5 b4 d5 c5]/2")`} punchcard />

The division by two means that the sequence will be played over the course of two cycles.
You can also use decimal numbers for any tempo you like (`/2.75`).

<MiniRepl client:idle tune={`note("[e5 b4 d5 c5]/2.75")`} punchcard />

## Angle Brackets

Using angle brackets `<>`, we can define the sequence length based on the number of events:

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5>")`} punchcard />

The above snippet is the same as:

<MiniRepl client:idle tune={`note("[e5 b4 d5 c5]/4")`} punchcard />

The advantage of the angle brackets, is that we can add more events without needing to change the number at the end.

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5 e5>")`} punchcard />

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5 e5 b4>")`} punchcard />

This is more similar to traditional music sequencers and piano rolls, where adding a note increases the perceived overall duration.
We can also play a certain number of notes per cycle by using angle brackets with multiplication:

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5 a4 c5>*8")`} punchcard />

Now we are playing 8 notes per cycle!

## Subdividing time with bracket nesting

To create more interesting rhythms, you can _nest_ or _enclose_ sequences (put sequences inside sequences) with brackets `[]`, like this:

Compare the difference between the following:

<MiniRepl client:idle tune={`note("e5 b4 c5 d5 c5 b4")`} />
<MiniRepl client:idle tune={`note("e5 [b4 c5] d5 c5 b4")`} />
<MiniRepl client:idle tune={`note("e5 [b4 c5] d5 [c5 b4]")`} />
<MiniRepl client:idle tune={`note("e5 [b4 c5] d5 [c5 b4 d5 e5]")`} />
<MiniRepl client:idle tune={`note("e5 [b4 c5] d5 [c5 b4 [d5 e5]]")`} />

What's going on here? When we nest/enclose multiple events inside brackets (`[]`), their duration becomes the length of one event in the outer sequence.

This is a very simple change to make, but it has profound consequences.
Remember what we said earlier about how the cycles in tidal stay the same length, and the individual event lengths are divided up in this cycle?
Well, what this means is that in TidalCycles, not only can you divide time any way you want, and you can also subdivide time any way you want!

## Rests

The "~" represents a rest, and will create silence between other events:

<MiniRepl client:idle tune={`note("[b4 [~ c5] d5 e5]")`} punchcard />

Alternatively, "-" can be used instead of "~". It means the same thing.

## Parallel / polyphony

Using commas, we can play chords.
The following are the same:

<MiniRepl client:idle tune={`note("[g3,b3,e4]")`} />
<MiniRepl client:idle tune={`note("g3,b3,e4")`} punchcard canvasHeight={80} />

But to play multiple chords in a sequence, we have to wrap them in brackets:

<MiniRepl client:idle tune={`note("<[g3,b3,e4] [a3,c3,e4] [b3,d3,f#4] [b3,e4,g4]>*2")`} punchcard />

## Elongation

With the "@" symbol, we can specify temporal "weight" of a sequence child:

<MiniRepl client:idle tune={`note("<[g3,b3,e4]@2 [a3,c3,e4] [b3,d3,f#4]>*2")`} punchcard />

Here, the first chord has a weight of 2, making it twice the length of the other chords. The default weight is 1.

## Replication

Using "!" we can repeat without speeding up:

<MiniRepl client:idle tune={`note("<[g3,b3,e4]!2 [a3,c3,e4] [b3,d3,f#4]>*2")`} punchcard />

## Randomness

Events with a "?" placed after them will have a 50% chance of being removed from the pattern:

<MiniRepl client:idle tune={`note("[g3,b3,e4]*8?")`} punchcard />

Adding a number between 0 and 1 after the "?" will affect the likelihood of the event being removed. For example, events with "?0.1" placed after them will have a 10% chance of being removed:

<MiniRepl client:idle tune={`note("[g3,b3,e4]*8?0.1")`} punchcard />

Events separated by a "|" will be chosen from at random:

<MiniRepl client:idle tune={`note("[g3,b3,e4] | [a3,c3,e4] | [b3,d3,f#4]")`} punchcard />

## Mini-notation review

To recap what we've learned so far, compare the following patterns:

<MiniRepl client:idle tune={`note("<g3 b3 e4 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4] [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]/2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]*2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4] _ [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]@2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]!2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]? [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3|b3|e4] [a3,c3,e4] [b3,d3,f#4]>*2")`} />

## Euclidian rhythms

Using round brackets after an event, we can create rhythmical sub-divisions based on three parameters: `beats`, `segments` and `offset`.
This algorithm can be found in many different types of music software, and is often referred to as a [Euclidean rhythm](https://en.wikipedia.org/wiki/Euclidean_rhythm) sequencer, after computer scientist Godfriend Toussaint.
Why is it interesting? Well, consider the following simple example:

<MiniRepl client:idle tune={`s("bd(3,8,0)")`} punchcard canvasHeight={50} />

Sound familiar?
This is a popular Euclidian rhythm going by various names, such as "Pop Clave".
These rhythms can be found in all musical cultures, and the Euclidian rhythm algorithm allows us to express them extremely easily.
Writing this rhythm out in full require describing:

<MiniRepl client:idle tune={`s("bd ~ ~ bd ~ ~ bd ~")`} punchcard canvasHeight={50} />

But using the Euclidian rhythm notation, we only need to express "3 beats over 8 segments, starting on position 1".

This makes it easy to write patterns with interesting rhythmic structures and variations that still sound familiar:

<MiniRepl client:idle tune={`note("e5(2,8) b4(3,8) d5(2,8) c5(3,8)").slow(2)`} punchcard canvasHeight={50} />

Note that since the example above does not use the third `offset` parameter, it can be written simply as `"(3,8)"`.

<MiniRepl client:idle tune={`s("bd(3,8)")`} punchcard canvasHeight={50} />

Let's look at those three parameters in detail.

### Beats

`beats`: the first parameter controls how may beats will be played.
Compare these:

<MiniRepl client:idle tune={`s("bd(2,8)")`} punchcard canvasHeight={50} />
<MiniRepl client:idle tune={`s("bd(5,8)")`} punchcard canvasHeight={50} />
<MiniRepl client:idle tune={`s("bd(7,8)")`} punchcard canvasHeight={50} />

### Segments

`segments`: the second parameter controls the total amount of segments the beats will be distributed over:

<MiniRepl client:idle tune={`s("bd(3,4)")`} punchcard canvasHeight={50} />
<MiniRepl client:idle tune={`s("bd(3,8)")`} punchcard canvasHeight={50} />
<MiniRepl client:idle tune={`s("bd(3,13)")`} punchcard canvasHeight={50} />

### Offsets

`offset`: the third (optional) parameter controls the starting position for distributing the beats.
We need a secondary rhythm to hear the difference:

<MiniRepl client:idle tune={`s("bd(3,8,0), hh cp")`} punchcard />
<MiniRepl client:idle tune={`s("bd(3,8,3), hh cp")`} punchcard />
<MiniRepl client:idle tune={`s("bd(3,8,5), hh cp")`} punchcard />

## Mini-notation exercise

The most fun thing about the mini-notation, is that everything you have just learned can be combined in various ways!

Starting with this one `n`, can you make a _pattern string_ that uses every single mini-notation element above?

<MiniRepl client:idle tune={`n("60")`} />

<br />

Next: How do [Samples](/learn/samples) play into this?


---
title: Mondo Notation
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Mondo Notation

"Mondo Notation" is a new kind of notation that is similar to [Mini Notation](/learn/mini-notation/), but with enough abilities to make it work as a standalone pattern language.
Here's an example:

<MiniRepl
  mondo
  client:idle
  tune={`$ note (c2 # euclid <3 6 3> <8 16>) # *2 
  # s "sine" # add (note [0 <12 24>]*2)
  # dec(sine # range .2 2) 
  # room .5
  # lpf (sine/3 # range 120 400)
  # lpenv (rand # range .5 4)
  # lpq (perlin # range 5 12 # * 2)
  # dist 1 # fm 4 # fmh 5.01 # fmdecay <.1 .2>
  # postgain .6 # delay .1 # clip 5

$ s [bd bd bd bd] # bank tr909 # clip .5

# ply <1 [1 [2 4]]>

$ s oh\*4 # press # bank tr909 # speed.8

# dec (<.02 .05>\*2 # add (saw/8 # range 0 1))

`}
/>

## Mondo in the REPL

For now, you can only use mondo in the repl like this:

<MiniRepl client:idle tune={'mondo`s hh*8`'} />

The rest of this site will only use the mondo notation itself.
In the future, the REPL might get a way to use mondo notation directly.

## Calling Functions

Compared to Mini Notation, the most notable feature of Mondo Notation is the ability to call functions using round brackets:

<MiniRepl mondo client:idle tune={`(s hh*8)`} />

The first element inside the brackets is the function name. In JS, this would look like:

<MiniRepl client:idle tune={`s("hh*8")`} />

The outermost parens are not needed, so we can drop them:

<MiniRepl mondo client:idle tune={`s hh*8`} />

## Mini Notation Features

Besides function calling with round parens, Mondo Notation has a lot in common with Mini Notation:

### Brackets

- `[]` for 1-cycle sequences
- `<>` for multi-cycle sequences
- `{}` for stepped sequences (more on that later)

### Infix Operators

- \* => [fast](/learn/time-modifiers/#fast)
- / => [slow](/learn/time-modifiers/#slow)
- ! => [extend](/learn/stepwise/#extend)
- @ => [expand](/learn/stepwise/#expand)
- % => [pace](/learn/stepwise/#pace)
- ? => [degradeBy](/learn/random-modifiers/#degradeby) (currently requires right operand)
- : => tail (creates a list)
- .. => range (between numbers)
- , => [stack](/learn/factories/#stack)
- | => [chooseIn](/learn/random-modifiers/#choose)

### Example

<MiniRepl
  mondo
  client:idle
  tune={`note <
[e5 [b4 c5] d5 [c5 b4]]
[a4 [a4 c5] e5 [d5 c5]]
[b4 [~ c5] d5 e5]
[c5 a4 a4 ~]
[[~ d5] [~ f5] a5 [g5 f5]]
[e5 [~ c5] e5 [d5 c5]]
[b4 [b4 c5] d5 e5]
[c5 a4 a4 ~]
>`}
/>

## Chaining Functions

Similar to how "." works in javascript (JS), we can chain functions calls with the "#" operator:

<MiniRepl
  mondo
  client:idle
  tune={`n <0 2 4 [3 1] -1>*4 
 # scale C4:minor 
 # jux rev 
 # dec .2
 # delay .5`}
/>

Here's the same written in JS:

<MiniRepl
  client:idle
  tune={`n("<0 2 4 [3 1] -1>*4")
 .scale("C4:minor")
 .jux(rev)
 .dec(.2)
 .delay(.5)`}
/>

### Chaining Functions Locally

A function can be applied to a single element by wrapping it in round parens:

<MiniRepl mondo client:idle tune={`s [bd hh bd (cp # delay .6)] # bank tr909`} />

in this case, `delay .6` will only be applied to `cp`. compare this with the JS version:

<MiniRepl client:idle tune={`s(seq("bd", "hh", "bd", "cp".delay(.6))).bank('tr909')`} />

here we can see how much we can save when there's no boundary between mini notation and function calls!

### Chaining Infix Operators

Infix operators exist as regular functions, so they can be chained as well:

<MiniRepl client:idle mondo tune={`s [bd hh] # bank tr909 # *2`} />

In this case, the \*2 will be applied to the whole pattern.

### Lambda Functions

Some functions in strudel expect a function as input, for example:

<MiniRepl client:idle tune={`n("0 .. 7").scale("C:minor").sometimes(x=>x.dec(.1))`} />

in mondo, the `x=>x.` can be shortened to:

<MiniRepl client:idle mondo tune={`n 0..7 # scale C:minor # sometimes (# dec .1)`} />

chaining works as expected:

<MiniRepl client:idle mondo tune={`n 0..7 # scale C:minor # sometimes (# dec .1 # jux rev)`} />

## Strings

You can use "double quotes" and 'single quotes' to get a string:

<MiniRepl client:idle mondo tune={`n 0..7 # scale 'C minor'`} />

## Multiple Patterns

The `$` sign can be used to separate multiple patterns:

<MiniRepl
  client:idle
  mondo
  tune={`$ s [bd rim [~ bd] rim] # bank tr707
$ chord <Dm9!3 Db7> # voicing
  # struct[x ~ ~ x ~ x ~ ~] # delay .5`}
/>

The `$` sign is an alias for `,` so it will create a stack behind the scenes.

## variables

using the `def` keyword, you can define variables:

<MiniRepl
  client:idle
  mondo
  tune={`
$ def melody [0 1 2 3]
$ n melody # scale C:minor
`}
/>


---
title: Notes
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Notes

Pitches are an important building block in many musical traditions.
In Strudel, pitches can be expressed as note names, note numbers or frequencies.
Here's the same pattern written in three different ways:

- `note`: letter notation, good for those who are familiar with western music theory:

  <MiniRepl client:idle tune={`note("a3 c#4 e4 a4")`} />

- `note`: number notation, good for those who want to use recognisable pitches, but don't care about music theory:

  <MiniRepl client:idle tune={`note("57 61 64 69")`} />

- `freq`: frequency notation, good for those who want to go beyond standardised tuning systems:

  <MiniRepl client:idle tune={`freq("220 275 330 440")`} />

Let's look at those in more detail...

## `note` names

Notes names can be notated with the note letter, followed by the octave number. You can notate flats with `b` and sharps with `#`.

<MiniRepl client:idle tune={`note("a3 c#4 e4 a4")`} />

By the way, you can edit the contents of the player, and press "update" to hear your change!
You can also press "play" on the next player without needing to stop the last one.

## `note` numbers

If you prefer, you can also use numbers with `note` instead:

<MiniRepl client:idle tune={`note("57 61 64 69")`} />

These numbers are interpreted as so called [MIDI numbers](https://www.inspiredacoustics.com/en/MIDI_note_numbers_and_center_frequencies), where adjacent whole numbers are one 'semitone' apart.

You could also write decimal numbers to get 'microtonal' pitches (in between the black and white piano notes):

<MiniRepl client:idle tune={`note("74.5 75 75.5 76")`} />

## `freq`

To get maximum freedom, you can also use `freq` to directly control the frequency:

<MiniRepl client:idle tune={`freq("220 275 330 440")`} />

## Hearing and frequency

In the above example, we play A3 (220Hz), C#4 natural (275Hz), E4 (330Hz) and A4 (440Hz), mirroring our previous examples.

But can you hear the difference between these individual frequencies?

<MiniRepl client:idle tune={`freq("220 221 223 224")`} />

How about these?

<MiniRepl client:idle tune={`freq("2020 2021 2023 2024")`} />

The higher we go up...

<MiniRepl client:idle tune={`freq("5020 5021 5023 5024")`} />

The less distance we can hear between the frequencies!

<MiniRepl client:idle tune={`freq("10020 10021 10023 10024")`} />

Why is this? [Human hearing operates logarithmically](https://www.audiocheck.net/soundtests_nonlinear.php).

## From notes to sounds

In this page, when we played a pattern of notes like this:

<MiniRepl client:idle tune={`note("a3 c#4 e4 a4")`} />

We heard a simple synthesised sound, in fact we heard a [triangle wave oscillator](https://en.wikipedia.org/wiki/Triangle_wave).

This is the default synthesiser used by Strudel, but how do we then make different sounds in Strudel?

Let's find out in the next page on [Sounds](/learn/sounds).

<br />


---
title: Offline
layout: ../../layouts/MainLayout.astro
---

# Using Strudel Offline

You can use Strudel even without a network! When you first visit the [Strudel REPL](https://strudel.cc/),
your browser will download the whole web app including documentation.
When the download is finished (&lt;1MB), you can visit the website even when offline,
getting the downloaded website instead of the online one.

When the site gets updated, your browser will download that update on the next online visit.
When an update is available, the site will refresh after the download is finished.

This works because Strudel is implemented as progessive web app (using [Vite PWA](https://vite-pwa-org.netlify.app/)).

## Samples

While the browser will download the app itself, samples are only downloaded when you're actively using them.
So to make sure a specific set of samples is available when offline, just use them.
Also, only samples from these domains will be cached for offline use:

- `https://raw.githubusercontent.com/*` for samples uploaded to github
- `https://freesound.org/*` / `https://cdn.freesound.org/*` for freesound
- `https://shabda.ndre.gr/.*` for shabda

## Inspecting / Clearing Cache

You can view all cached files in your browser.

### Firefox

- Open the Developer Tools (`Tools > Web Developer > Web Developer Tools`)
- go to `Storage` tab and expand `Cache Storage > https://strudel.cc`.
- or go to the `Application` tab and view the latest updates in `Service Workers`

### Chromium based Browsers

- Open Developer Tools (`Right Click > Inspect`)
- go to the `Application` tab
- view downloaded files under `Cache > Cache Storage`
- view the latest updates in `Service Workers`

## Strudel Standalone App

You can also install Strudel as a standalone app on most devices.
A standalone app has its own desktop / homescreen icon and launches in a separate window,
without the browser ui.

<figure>
  ![Strudel on MacOS](/pwa/strudel-macos.png)
  <figcaption>Strudel on MacOS</figcaption>
</figure>

### Desktop

With a chromium based browser:

1. go to the [Strudel REPL](https://strudel.cc).
2. on the right of the adress bar, click `install Strudel REPL`
3. the REPL should now run as a standalone chromium app

Without a chromium based browser, you can use [nativefier](https://github.com/nativefier/nativefier) to generate a desktop app:

1. make sure you have NodeJS installed
2. run `npx nativefier strudel.cc`

<figure>
  ![Strudel on Linux](/pwa/strudel-linux.png)
  <figcaption>Strudel on Linux</figcaption>
</figure>

### iOS

1. open to the [Strudel REPL](https://strudel.cc/) in safari
2. press the share icon and tab `Add to homescreen`
3. You should now have a strudel app icon that opens the repl in full screen

### Android

1. open to the [Strudel REPL](https://strudel.cc/)
2. Tab the install button at the bottom

Ok, what are [Patterns](/technical-manual/patterns) all about?


---
title: Random Modifiers
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Random Modifiers

These methods add random behavior to your Patterns.

## choose

<JsDoc client:idle name="choose" h={0} />

## wchoose

<JsDoc client:idle name="wchoose" h={0} />

## chooseCycles

<JsDoc client:idle name="chooseCycles" h={0} />

## wchooseCycles

<JsDoc client:idle name="wchooseCycles" h={0} />

## degradeBy

<JsDoc client:idle name="Pattern.degradeBy" h={0} />

## degrade

<JsDoc client:idle name="Pattern.degrade" h={0} />

## undegradeBy

<JsDoc client:idle name="Pattern.undegradeBy" h={0} />

## undegrade

<JsDoc client:idle name="Pattern.undegrade" h={0} />

## sometimesBy

<JsDoc client:idle name="Pattern.sometimesBy" h={0} />

## sometimes

<JsDoc client:idle name="Pattern.sometimes" h={0} />

## someCyclesBy

<JsDoc client:idle name="Pattern.someCyclesBy" h={0} />

## someCycles

<JsDoc client:idle name="Pattern.someCycles" h={0} />

## often

<JsDoc client:idle name="Pattern.often" h={0} />

## rarely

<JsDoc client:idle name="Pattern.rarely" h={0} />

## almostNever

<JsDoc client:idle name="Pattern.almostNever" h={0} />

## almostAlways

<JsDoc client:idle name="Pattern.almostAlways" h={0} />

## never

<JsDoc client:idle name="Pattern.never" h={0} />

## always

<JsDoc client:idle name="Pattern.always" h={0} />

Next up: [Conditional Modifiers](/learn/conditional-modifiers)


---
title: Samples
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Samples

Samples are the most common way to make sound with tidal and strudel.
A sample is a (commonly short) piece of audio that is used as a basis for sound generation, undergoing various transformations.
Music that is based on samples can be thought of as a collage of sound. [Read more about Sampling](<https://en.wikipedia.org/wiki/Sampling_(music)>)

Strudel allows loading samples in the form of audio files of various formats (wav, mp3, ogg) from any publicly available URL.

# Default Samples

By default, strudel comes with a built-in "sample map", providing a solid base to play with.

<MiniRepl client:idle tune={`s("bd sd [~ bd] sd,hh*16, misc")`} />

Here, we are using the `s` function to play back different default samples (`bd`, `sd`, `hh` and `misc`) to get a drum beat.

For drum sounds, strudel uses the comprehensive [tidal-drum-machines](https://github.com/ritchse/tidal-drum-machines) library, with the following naming convention:

| Drum                 | Abbreviation |
| -------------------- | ------------ |
| Bass drum, Kick drum | bd           |
| Snare drum           | sd           |
| Rimshot              | rim          |
| Clap                 | cp           |
| Closed hi-hat        | hh           |
| Open hi-hat          | oh           |
| Crash                | cr           |
| Ride                 | rd           |
| High tom             | ht           |
| Medium tom           | mt           |
| Low tom              | lt           |

<img src="/img/drumset.png" />

<a class="text-right text-xs" href="https://de.wikipedia.org/wiki/Schlagzeug#/media/Datei:Drum_set.svg" target="_blank">
  original von Pbroks13
</a>

More percussive sounds:

| Source                              | Abbreviation |
| ----------------------------------- | ------------ |
| Shakers (and maracas, cabasas, etc) | sh           |
| Cowbell                             | cb           |
| Tambourine                          | tb           |
| Other percussions                   | perc         |
| Miscellaneous samples               | misc         |
| Effects                             | fx           |

Furthermore, strudel also loads instrument samples from [VCSL](https://github.com/sgossner/VCSL) by default.

To see which sample names are available, open the `sounds` tab in the [REPL](https://strudel.cc/).

You can also create custom aliases for existing sounds using the `soundAlias` function:

<MiniRepl
  client:idle
  tune={`soundAlias('RolandTR808_bd', 'kick')
s("kick")`}
/>

Note that only the sample maps (mapping names to URLs) are loaded initially, while the audio samples themselves are not loaded until they are actually played.
This behaviour of loading things only when they are needed is also called `lazy loading`.
While it saves resources, it can also lead to sounds not being audible the first time they are triggered, because the sound is still loading.
[This might be fixed in the future](https://codeberg.org/uzu/strudel/issues/187)

# Sound Banks

If we open the `sounds` tab and then `drum-machines`, we can see that the drum samples are all prefixed with drum machine names: `RolandTR808_bd`, `RolandTR808_sd`, `RolandTR808_hh` etc..

We _could_ use them like this:

<MiniRepl client:idle tune={`s("RolandTR808_bd RolandTR808_sd,RolandTR808_hh*16")`} />

... but thats obviously a bit much to write. Using the `bank` function, we can shorten this to:

<MiniRepl client:idle tune={`s("bd sd,hh*16").bank("RolandTR808")`} />

You could even pattern the bank to switch between different drum machines:

<MiniRepl client:idle tune={`s("bd sd,hh*16").bank("<RolandTR808 RolandTR909>")`} />

Behind the scenes, `bank` will just prepend the drum machine name to the sample name with `_` to get the full name.
This of course only works because the name after `_` (`bd`, `sd` etc..) is standardized.
Also note that some banks won't have samples for all sounds!

# Selecting Sounds

If we open the `sounds` tab again, followed by tab `drum machines`, there is also a number behind each name, indicating how many individual samples are available.
For example `RolandTR909_hh(4)` means there are 4 samples of a TR909 hihat available.
By default, `s` will play the first sample, but we can select the other ones using `n`, starting from 0:

<MiniRepl client:idle tune={`s("hh*8").bank("RolandTR909").n("0 1 2 3")`} />

Numbers that are too high will just wrap around to the beginning

<MiniRepl client:idle tune={`s("hh*8").bank("RolandTR909").n("0 1 2 3 4 5 6 7")`} />

Here, 0-3 will play the same sounds as 4-7, because `RolandTR909_hh` only has 4 sounds.

Selecting sounds also works inside the mini notation, using "`:`" like this:

<MiniRepl
  client:idle
  tune={`s("bd*4,hh:0 hh:1 hh:2 hh:3 hh:4 hh:5 hh:6 hh:7")
.bank("RolandTR909")`}
/>

# Loading Custom Samples

You can load a non-standard sample map using the `samples` function.

## Loading samples from file URLs

In this example we assign names `bassdrum`, `hihat` and `snaredrum` to specific audio files on a server:

<MiniRepl
  client:idle
  tune={`samples({
  bassdrum: 'bd/BT0AADA.wav',
  hihat: 'hh27/000_hh27closedhh.wav',
  snaredrum: ['sd/rytm-01-classic.wav', 'sd/rytm-00-hard.wav'],
}, 'https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/');
 
s("bassdrum snaredrum:0 bassdrum snaredrum:1, hihat*16")`}
/>

You can freely choose any combination of letters for each sample name. It is even possible to override the default sounds.
The names you pick will be made available in the `s` function.
Make sure that the URL and each sample path form a correct URL!

In the above example, `bassdrum` will load:

```
https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/bd/BT0AADA.wav
|----------------------base path --------------------------------|--sample path-|
```

Note that we can either load a single file, like for `bassdrum` and `hihat`, or a list of files like for `snaredrum`!
As soon as you run the code, your chosen sample names will be listed in `sounds` -> `user`.

## Loading Samples from a strudel.json file

The above way to load samples might be tedious to write out / copy paste each time you write a new pattern.
To avoid that, you can simply pass a URL to a `strudel.json` file somewhere on the internet:

<MiniRepl
  client:idle
  tune={`samples('https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/strudel.json')
s("bd sd bd sd,hh*16")`}
/>

The file is expected to define a sample map using JSON, in the same format as described above.
Additionally, the base path can be defined with the `_base` key.
The last section could be written as:

```json
{
  "_base": "https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/",
  "bassdrum": "bd/BT0AADA.wav",
  "snaredrum": "sd/rytm-01-classic.wav",
  "hihat": "hh27/000_hh27closedhh.wav"
}
```

Please note that browsers will often cache `strudel.json` on first load, and keep using the cached
version even if the orginal has been updated. If this bites you (for example while developing a new
sample pack), you can force the browser to download a new copy by i.e. changing capitalization of one
character in the URL, or adding a URL attribute, such as:

```javascript
samples('https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/strudel.json?version=2');
```

that gets ignored by GitHub (but changes the URL, forcing the browser to reload every time we increase
the version number).

It is also possible, of course, to just remove it from cache (deleting cache in browser Privacy settings,
or from the dev console if you're technically minded, or by using a cache deleting extension).

## Generating strudel.json

You can use [@strudel/sampler](https://www.npmjs.com/package/@strudel/sampler) to generate a strudel.json file for you, by running:

```sh
npx --yes @strudel/sampler --json > strudel.json
```

See other uses of strudel/sampler further below, under "From Disk via @strudel/sampler".

## Github Shortcut

Because loading samples from github is common, there is a shortcut:

<MiniRepl
  client:idle
  tune={`samples('github:tidalcycles/dirt-samples')
s("bd sd bd sd,hh*16")`}
/>

The format is `samples('github:<user>/<repo>/<branch>')`. If you omit `branch` (like above), the `main` branch will be used.
It assumes a `strudel.json` file to be present at the root of the repository:

```
https://raw.githubusercontent.com/<user>/<repo>/<branch>/strudel.json
```

## From Disk via "Import Sounds Folder"

If you don't want to upload your samples to the internet, you can also load them from your local disk.
Go to the `sounds` tab in the REPL and open the `import-sounds` tab below the search bar.
Press the "import sounds folder" button and select a folder that contains audio files.
The folder you select can also contain subfolders with audio files.
Example:

```
‚îî‚îÄ samples
   ‚îú‚îÄ swoop
   ‚îÇ  ‚îú‚îÄ swoopshort.wav
   ‚îÇ  ‚îú‚îÄ swooplong.wav
   ‚îÇ  ‚îî‚îÄ swooptight.wav
   ‚îî‚îÄ smash
      ‚îú‚îÄ smashhigh.wav
      ‚îú‚îÄ smashlow.wav
      ‚îî‚îÄ smashmiddle.wav
```

In the above example the folder `samples` contains 2 subfolders `swoop` and `smash`, which contain audio files.
If you select that `samples` folder, the `user` tab (next to the `import-sounds` tab) will then contain 2 new sounds: `swoop(3) smash(3)`
The individual samples can the be played normally like `s("swoop:0 swoop:1 smash:2")`.
The samples within each sound use zero-based indexing in alphabetical order.

## From Disk via @strudel/sampler

Instead of loading your samples into your browser with the "import sounds folder" button, you can also serve the samples from a local file server.
The easiest way to do this is using [@strudel/sampler](https://www.npmjs.com/package/@strudel/sampler):

```sh
cd samples
npx @strudel/sampler
```

Then you can load it via:

<MiniRepl
  client:idle
  tune={`samples('http://localhost:5432/');
 
n("<0 1 2>").s("swoop smash")`}
/>

The handy thing about `@strudel/sampler` is that it auto-generates the `strudel.json` file based on your folder structure.
You can see what it generated by going to `http://localhost:5432` with your browser.

Note: You need [NodeJS](https://nodejs.org/) installed on your system for this to work.

## Specifying Pitch

To make sure your samples are in tune when playing them with `note`, you can specify a base pitch like this:

<MiniRepl
  client:idle
  tune={`samples({
  'gtr': 'gtr/0001_cleanC.wav',
  'moog': { 'g3': 'moog/005_Mighty%20Moog%20G3.wav' },
}, 'github:tidalcycles/dirt-samples');
note("g3 [bb3 c4] <g4 f4 eb4 f3>@2").s("gtr,moog").clip(1)
  .gain(.5)`}
/>

We can also declare different samples for different regions of the keyboard:

<MiniRepl
  client:idle
  tune={`setcpm(60)
samples({
  'moog': {
    'g2': 'moog/004_Mighty%20Moog%20G2.wav',
    'g3': 'moog/005_Mighty%20Moog%20G3.wav',
    'g4': 'moog/006_Mighty%20Moog%20G4.wav',
  }}, 'github:tidalcycles/dirt-samples')

note("g2!2 <bb2 c3>!2, <c4@3 [<eb4 bb3> g4 f4]>")
.s('moog').clip(1)
.gain(.5)`}
/>

The sampler will always pick the closest matching sample for the current note!

Note that this notation for pitched sounds also works inside a `strudel.json` file.

## Shabda

If you don't want to select samples by hand, there is also the wonderful tool called [shabda](https://shabda.ndre.gr/).
With it, you can enter any sample name(s) to query from [freesound.org](https://freesound.org/). Example:

<MiniRepl
  client:idle
  tune={`samples('shabda:bass:4,hihat:4,rimshot:2')

$: n("0 1 2 3 0 1 2 3").s('bass')
$: n("0 1*2 2 3*2").s('hihat').clip(1)
$: n("~ 0 ~ 1 ~ 0 0 1").s('rimshot')`}
/>

You can also generate artificial voice samples with any text, in multiple languages.
Note that the language code and the gender parameters are optional and default to `en-GB` and `f`

<MiniRepl
  client:idle
  tune={`samples('shabda/speech:the_drum,forever')
samples('shabda/speech/fr-FR/m:magnifique')

$: s("the_drum*2").chop(16).speed(rand.range(0.85,1.1))
$: s("forever magnifique").slow(4).late(0.125)`}
/>

# Sampler Effects

Sampler effects are functions that can be used to change the behaviour of sample playback.

### begin

<JsDoc client:idle name="Pattern.begin" h={0} />

### end

<JsDoc client:idle name="Pattern.end" h={0} />

### loop

<JsDoc client:idle name="loop" h={0} />

### loopBegin

<JsDoc client:idle name="loopBegin" h={0} />

### loopEnd

<JsDoc client:idle name="loopEnd" h={0} />

### cut

<JsDoc client:idle name="cut" h={0} />

### clip

<JsDoc client:idle name="clip" h={0} />

### loopAt

<JsDoc client:idle name="Pattern.loopAt" h={0} />

### fit

<JsDoc client:idle name="fit" h={0} />

### chop

<JsDoc client:idle name="Pattern.chop" h={0} />

### striate

<JsDoc client:idle name="Pattern.striate" h={0} />

### slice

<JsDoc client:idle name="Pattern.slice" h={0} />

### splice

<JsDoc client:idle name="splice" h={0} />

### scrub

<JsDoc client:idle name="Pattern.scrub" h={0} />

### speed

<JsDoc client:idle name="speed" h={0} />

After samples, let's see what [Synths](/learn/synths) afford us.


---
title: Signals
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Continuous Signals

Signals are patterns with continuous values, meaning they have theoretically infinite steps.
They can provide streams of numbers that can be sampled at discrete points in time.

## saw

<JsDoc client:idle name="saw" h={0} />

## sine

<JsDoc client:idle name="sine" h={0} />

## cosine

<JsDoc client:idle name="cosine" h={0} />

## tri

<JsDoc client:idle name="tri" h={0} />

## square

<JsDoc client:idle name="square" h={0} />

## rand

<JsDoc client:idle name="rand" h={0} />

## Ranges from -1 to 1

There is also `saw2`, `sine2`, `cosine2`, `tri2`, `square2` and `rand2` which have a range from -1 to 1!

## perlin

<JsDoc client:idle name="perlin" h={0} />

## irand

<JsDoc client:idle name="irand" h={0} />

## brand

<JsDoc client:idle name="brand" h={0} />

## brandBy

<JsDoc client:idle name="brandBy" h={0} />

## mouseX

<JsDoc client:idle name="mousex" h={0} />

## mouseY

<JsDoc client:idle name="mousey" h={0} />

Next up: [Random Modifiers](/learn/random-modifiers)


---
title: Sounds
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Sounds

We can play sounds with `s`, in two different ways:

- `s` can trigger audio samples, where a sound file is loaded in the background and played back:
  <MiniRepl client:idle tune={`s("bd hh sd hh")`} />
- `s` can trigger audio synthesisers, which are synthesised in real-time using code also running in the background:
  <MiniRepl client:idle tune={`s("sawtooth square triangle sine")`} />

You can learn more about both of these approaches in the pages [Synths](/learn/synths) and [Samples](/learn/samples).

# Combining notes and sounds

In both of the above cases, we are no longer directly controlling the `note`/`freq` of the sound heard via `s`, as we were in the [Notes](/workshop/first-notes/) page.

So how can we both control the sound and the pitch? We can _combine_ `note`/`freq` with `s` to change the sound of our pitches:

<MiniRepl client:idle tune={`note("a3 c#4 e4 a4").s("sawtooth")`} />

<MiniRepl client:idle tune={`note("57 61 64 69").s("sine")`} />

<MiniRepl client:idle tune={`freq("220 275 330 440").s("triangle")`} />

The last example will actually sound the same with or without `s`, because `triangle` is the default value for `s`.

What about combining different notes with different sounds at the same time?

<MiniRepl client:idle tune={`freq("220 275 330 440 550").s("triangle sawtooth sine")`} />

Hmm, something interesting is going on there, related to there being five notes and three sounds.

Let's now take a step back and think about the Strudel [Code](/learn/code/) we've been hearing so far.


---
title: Stepwise patterning
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Stepwise patterning (experimental)

This is a developing area of strudel, and behaviour might change or be renamed in future versions. Feedback and ideas are welcome!

## Introduction

Usually in strudel, the only reference point for most pattern transformations is the _cycle_. Now it is possible to also work with _steps_, via a growing range of functions.

For example usually when you `fastcat` two patterns together, the cycles will be squashed into half a cycle each:

<MiniRepl client:idle tune={`fastcat("bd hh hh", "bd hh hh cp hh").sound()`} />

With the new stepwise `stepcat` function, the steps of the two patterns will be evenly distributed across the cycle:

<MiniRepl client:idle tune={`stepcat("bd hh hh", "bd hh hh cp hh").sound()`} />

By default, steps are counted according to the 'top level' in mini-notation. For example `"a [b c] d e"` has five events in it per cycle, but is counted as four steps, where `[b c]` is counted as a single step.

However, you can mark a different metrical level to count steps relative to, using a `^` at the start of a sub-pattern. If we do this to the subpattern in our example: `"a [^b c] d e"`, then the pattern is now counted as having _eight_ steps. This is because 'b' and 'c' are each counted as single steps, and the events in the pattern are twice as long, and so counted as two steps each.

## Pacing the steps

Some stepwise functions don't appear to do very much on their own, for example these two examples of the `expand` function sound exactly the same despite being expanded by different amounts:

<MiniRepl client:idle tune={`"c a f e".expand(2).note().sound("folkharp")`} />

<MiniRepl client:idle tune={`"c a f e".expand(4).note().sound("folkharp")`} />

The number of steps per cycle is being changed behind the scenes, but on its own, that doesn't do anything. You will hear a difference however, once you use another stepwise function with it, for example `stepcat`:

<MiniRepl
  client:idle
  tune={`stepcat("c a f e".expand(2), "g d").note()
  .sound("folkharp")`}
/>

<MiniRepl
  client:idle
  tune={`stepcat("c a f e".expand(4), "g d").note()
  .sound("folkharp")`}
/>

You should be able to hear that `expand` increases the duration of the steps of the first subpattern, proportionally to the second one.

You can also change the speed of a pattern to match a given number of steps per cycle, with the `pace` function:

<MiniRepl
  client:idle
  tune={`stepcat("c a f e".expand(2), "g d").note()
  .sound("folkharp")
  .pace(8)`}
/>

<MiniRepl
  client:idle
  tune={`stepcat("c a f e".expand(4), "g d").note()
  .sound("folkharp")
  .pace(8)`}
/>

The first example has ten steps, and the second example has 18 steps, but are then both played a rate of 8 steps per cycle.

The argument to `expand` can also be patterned, and will be treated in a stepwise fashion. This means that the patterns from the changing values in the argument will be `stepcat`ted together:

<MiniRepl client:idle tune={`note("c a f e").sound("folkharp").expand("3 2 1 1 2 3")`} />

This results in a dense pattern, because the different expanded versions are squashed into a single cycle. `pace` is again handy here for slowing down the pattern to a particular number of steps per cycle:

<MiniRepl client:idle tune={`note("c a f e").sound("folkharp").expand("3 2 1 1 2 3").pace(8)`} />

Earlier versions of many of these functions had `s_` prefixes, and the `pace` function was previously known as `steps`. These still exist as aliases, but may have changed behaviour and will soon be removed. Please update your patterns!

## Stepwise functions

### pace

<JsDoc client:idle name="pace" h={0} />

### stepcat

<JsDoc client:idle name="stepcat" h={0} />

### stepalt

<JsDoc client:idle name="stepalt" h={0} />

### expand

<JsDoc client:idle name="expand" h={0} />

### contract

<JsDoc client:idle name="contract" h={0} />

### extend

<JsDoc client:idle name="extend" h={0} />

### take

<JsDoc client:idle name="take" h={0} />

### drop

<JsDoc client:idle name="drop" h={0} />

### polymeter

<JsDoc client:idle name="polymeter" h={0} />

### shrink

<JsDoc client:idle name="shrink" h={0} />

### grow

<JsDoc client:idle name="grow" h={0} />

### tour

<JsDoc client:idle name="tour" h={0} />

### zip

<JsDoc client:idle name="zip" h={0} />


---
title: Strudel vs Tidal
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Comparing Strudel and Tidal

This page is dedicated to exisiting tidal users, giving an overview of all the differences between Strudel and Tidal.

## Language

Strudel is written in JavaScript, while Tidal is written in Haskell.

### Example

This difference is most obvious when looking at the syntax:

```haskell
iter 4 $ every 3 (||+ n "10 20") $ (n "0 1 3") # s "triangle" # crush 4
```

One _could_ express that pattern to Strudel like so:

```
iter(4, every(3, add.squeeze("10 20"), n("0 1 3").s("triangle").crush(4)))
```

- The `$` operator does not exist, so the `iter` function has to wrap everything in parens.
- Custom operators like `||+` are explicit function calls, `add.squeeze` in this case
- The `#` operator is replaced with a chained function call `# crush 4` => `.crush(4)`

Unlike Haskell, JavaScript lacks the ability to define custom infix
operators, or change the meaning of existing ones.

Before you discard Strudel as an unwieldy paren monster, look at this alternative way to write the above:

```
n("0 1 3").every(3, add.squeeze("10 20")).iter(4).s("triangle").crush(4)
```

By reordering calls, the parens are much less nested.
As a general rule by thumb, you could say that everything Tidal does with `$` is reversed in Strudel:

`iter 4 $ every 3 (||+ n "10 20") $ (n "0 1 3")`

becomes

`n("0 1 3").every(3, add.squeeze("10 20")).iter(4)`

Simply put, `foo x $ bar x` becomes `bar(x).foo(x)`.

### Operators

The [custom operators of tidal](https://tidalcycles.org/docs/reference/pattern_structure/#all-the-operators) are normal functions in strudel:

| function    | tidal  | strudel |
| ----------- | ------ | ------- |
| add         | \|+ n  | .add(n) |
| subtract    | \|- n  | .sub(n) |
| multiply    | \|\* n | .mul(n) |
| divide      | \|\/ n | .div(n) |
| modulo      | \|\% n | .mod(n) |
| left values | \|\< n | .set(n) |

The above list only displays the operators taking the structure comes from the `left`.
For each of those, a `right` and `both` variant also exists.
As this directional thinking only works with code, strudel calls these `in` / `out` / `mix`:

| direction | tidal   | strudel     |
| --------- | ------- | ----------- |
| left      | \|+ n   | .add.in(n)  |
| right     | +\| n   | .add.out(n) |
| both      | \|+\| n | .add.mix(n) |

Instead of `+` / `add`, you can use any of the available operators of the first list.

## Function Compatibility

[This issue](https://codeberg.org/uzu/strudel/issues/31) tracks which Tidal functions are implemented in Strudel.
The list might not be 100% up to date and probably also misses some functions completely..
Feel encouraged to search the source code for a function you're looking for.
If you find a function that's not on the list, please tell!

## Control Params

As seen in the example, the `#` operator (shorthand for `|>`) is also just a function call in strudel.
So `note "c5" # s "gtr"` becomes `note("c5").s('gtr')`.

[This file](https://codeberg.org/uzu/strudel/src/branch/main/packages/core/controls.mjs) lists all available control params.
Note that not all of those work in the Webaudio Output of Strudel.
If you find a tidal control that's not on the list, please tell!

## Sound

Tidal is commonly paired with Superdirt / Supercollider for sound generation.
While Strudel also has a way of [communicating with Superdirt](/learn/input-output/),
it aims to provide a standalone live coding environment that runs entirely in the browser.

### Audio Effects

Many of SuperDirt's effects have been reimplemented in Strudel, using the Web Audio API.
You can find a [list of available effects here](/learn/effects/).

### Sampler

Strudel's sampler supports [a subset](/learn/samples) of Superdirt's sampler.
Also, samples are always loaded from a URL rather than from the disk, although [that might be possible in the future](https://codeberg.org/uzu/strudel/issues/118).

## Evaluation

The Strudel REPL does not support [block based evaluation](https://codeberg.org/uzu/strudel/issues/34) yet.
You can use labeled statements and `_` to mute:

<MiniRepl
  client:visible
tune={`$: n("[0 .. 8]*8/9").scale("C:minor:pentatonic")

\_$: s("bd\*4").bank('RolandTR909')`}
/>

## Tempo

Strudels tempo is 1 cycle per second, while tidal defaults to `0.5625`.
You can get the same tempo as tidal with:

```
note("c a f e").fast(.5625);
```

Next up: the [REPL](/technical-manual/repl)


---
title: Synths
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Synths

In addition to the sampling engine, strudel comes with a synthesizer to create sounds on the fly.

## Basic Waveforms

The basic waveforms are `sine`, `sawtooth`, `square` and `triangle`, which can be selected via `sound` (or `s`):

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(2))
.sound("<sawtooth square triangle sine>")
._scope()`}
/>

If you don't set a `sound` but a `note` the default value for `sound` is `triangle`!

## Noise

You can also use noise as a source by setting the waveform to: `white`,¬†`pink` or `brown`. These are different
flavours of noise, here written from hard to soft.

<MiniRepl client:idle tune={`sound("<white pink brown>")._scope()`} />

Here's a more musical example of how to use noise for hihats:

<MiniRepl
  client:idle
  tune={`sound("bd*2,<white pink brown>*8")
.decay(.04).sustain(0)._scope()`}
/>

Some amount of pink noise can also be added to any oscillator by using the `noise` paremeter:

<MiniRepl client:idle tune={`note("c3").noise("<0.1 0.25 0.5>")._scope()`} />

You can also use the `crackle` type to play some subtle noise crackles. You can control noise amount by using the `density` parameter:

<MiniRepl client:idle tune={`s("crackle*4").density("<0.01 0.04 0.2 0.5>".slow(2))._scope()`} />

### Additive Synthesis

Periodic waveforms are composed of several [harmonics](https://en.wikipedia.org/wiki/Harmonic) above a fundamental frequency, lying at integer multiples. These overtones combine to give a sound its unique timbral quality.

For the basic waveforms, we offer you control over these harmonics with the `partials` and `phases` functions.

#### Partials

`partials` refers to the magnitude of each harmonic relative to the fundamental frequency. They can thus be used to spectrally filter these waveforms and tame some of their harshness:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(2))
.sound("sawtooth")
.partials([1, 1, "<1 0>", "<1 0>", "<1 0>", "<1 0>", "<1 0>"])
._scope()`}
/>

`partials` can also be used to construct _new_ waveforms not present in our basic set with the 'user' sound source:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(2))
.sound("user")
.partials([1, 0, 0.3, 0, 0.1, 0, 0, 0.3])
._scope()`}
/>

We may algorithmically construct lists of magnitudes with Javascript code like:

<MiniRepl
  client:idle
  tune={`const numHarmonics = 22;
note("c2 <eb2 <g2 g1>>".fast(2))
.sound("saw")
.partials(new Array(numHarmonics).fill(1))
._scope()`}
/>

which acts as a spectral filter. Or:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>").fast(2)
.sound("user")
.partials(new Array(50).fill(0)
  .map((_, idx) => ((-1) ** (idx + 1)) / (idx + 1))
)
._scope()`}
/>

which recovers a familiar waveform.

`partials` is also compatible with pattern functions designed to produce lists, like `randL` or `binaryL`:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>").fast(2)
.sound("user")
.partials(randL(10))
._scope()`}
/>

and with lists _of_ patterns:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(4))
.sound("user")
.partials([1, 0, "0 1", "0 1 0.3", rand])
._scope()`}
/>

Note that the first value in the `partials` array controls the magnitude of the fundamental harmonic rather than the DC offset, which is fixed at 0.

#### Phases

Earlier, we mentioned that periodic waveforms can be broken into a set of harmonics above a fundamental frequency. Each harmonic has two defining properties: its magnitude (how loud it is) and its phase, which determines where in its cycle that sine wave starts when the waveform is built.

These phases too can be declared in Strudel and can give your sounds interesting depth.

<MiniRepl
  client:idle
  tune={`s("saw").seg(16).n(irand(12)).scale("F1:minor")
  .penv(48).panchor(0).pdec(0.05)
  .delay(0.25).room(0.25)
  .compressor(-20).vib(0.3)
  .partials(randL(200))
  .phases(randL(200))`}
/>

## Vibrato

### vib

<JsDoc client:idle name="vib" h={0} />

### vibmod

<JsDoc client:idle name="vibmod" h={0} />

## FM Synthesis

FM Synthesis is a technique that changes the frequency of a basic waveform rapidly to alter the timbre.

You can use fm with any of the above waveforms, although the below examples all use the default triangle wave.

### fm

<JsDoc client:idle name="fm" h={0} />

### fmh

<JsDoc client:idle name="fmh" h={0} />

### fmattack

<JsDoc client:idle name="fmattack" h={0} />

### fmdecay

<JsDoc client:idle name="fmdecay" h={0} />

### fmsustain

<JsDoc client:idle name="fmsustain" h={0} />

### fmenv

<JsDoc client:idle name="fmenv" h={0} />

## Wavetable Synthesis

Strudel can also use the sampler to load custom waveforms as a replacement of the default waveforms used by WebAudio for the base synth. A default set of more than 1000 wavetables is accessible by default (coming from the [AKWF](https://www.adventurekid.se/akrt/waveforms/adventure-kid-waveforms/) set). You can also import/use your own. A wavetable is a one-cycle waveform, which is then repeated to create a sound at the desired frequency. It is a classic but very effective synthesis technique.

Any sample preceded by the `wt_` prefix will be loaded as a wavetable. This means that the `loop` argument will be set to `1` by default. You can scan over the wavetable by using `loopBegin` and `loopEnd` as well.

<MiniRepl
  client:idle
  tune={`samples('bubo:waveforms');
note("<[g3,b3,e4]!2 [a3,c3,e4] [b3,d3,f#4]>")
.n("<1 2 3 4 5 6 7 8 9 10>/2").room(0.5).size(0.9)
.s('wt_flute').velocity(0.25).often(n => n.ply(2))
.release(0.125).decay("<0.1 0.25 0.3 0.4>").sustain(0)
.cutoff(2000).cutoff("<1000 2000 4000>").fast(4)
._scope()
`}
/>

## ZZFX

The "Zuper Zmall Zound Zynth" [ZZFX](https://github.com/KilledByAPixel/ZzFX) is also integrated in strudel.
Developed by [Frank Force](https://frankforce.com/), it is a synth and FX engine originally intended to be used for size coding games.

It has 20 parameters in total, here is a snippet that uses all:

<MiniRepl
  client:idle
  tune={`note("c2 eb2 f2 g2") // also supports freq
  .s("{z_sawtooth z_tan z_noise z_sine z_square}%4")
  .zrand(0) // randomization
  // zzfx envelope
  .attack(0.001)
  .decay(0.1)
  .sustain(.8)
  .release(.1)
  // special zzfx params
  .curve(1) // waveshape 1-3
  .slide(0) // +/- pitch slide
  .deltaSlide(0) // +/- pitch slide (?)
  .noise(0) // make it dirty
  .zmod(0) // fm speed
  .zcrush(0) // bit crush 0 - 1
  .zdelay(0) // simple delay
  .pitchJump(0) // +/- pitch change after pitchJumpTime
  .pitchJumpTime(0) // >0 time after pitchJump is applied
  .lfo(0) // >0 resets slide + pitchJump + sets tremolo speed
  .tremolo(0.5) // 0-1 lfo volume modulation amount
  //.duration(.2) // overwrite strudel event duration
  //.gain(1) // change volume
  ._scope() // vizualise waveform (not zzfx related)
`}
/>

Note that you can also combine zzfx with all the other audio fx (next chapter).

Next up: [Audio Effects](/learn/effects)...


---
title: Time Modifiers
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Time Modifiers

The following functions modify a pattern temporal structure in some way.
Some of these have equivalent operators in the Mini Notation:

| function               | mini         |
| ---------------------- | ------------ |
| `"x".slow(2)`          | `"x/2"`      |
| `"x".fast(2)`          | `"x*2"`      |
| `"x".euclid(3,8)`      | `"x(3,8)"`   |
| `"x".euclidRot(3,8,1)` | `"x(3,8,1)"` |

## slow

<JsDoc client:idle name="Pattern.slow" h={0} />

## fast

<JsDoc client:idle name="Pattern.fast" h={0} />

## early

<JsDoc client:idle name="Pattern.early" h={0} />

## late

<JsDoc client:idle name="Pattern.late" h={0} />

## clip / legato

<JsDoc client:idle name="clip" h={0} />

## euclid

<JsDoc client:idle name="Pattern.euclid" h={0} />

### euclidRot

<JsDoc client:idle name="Pattern.euclidRot" h={0} />

### euclidLegato

<JsDoc client:idle name="Pattern.euclidLegato" h={0} />

## rev

<JsDoc client:idle name="Pattern.rev" h={0} />

## palindrome

<JsDoc client:idle name="palindrome" h={0} />

## iter

<JsDoc client:idle name="Pattern.iter" h={0} />

### iterBack

<JsDoc client:idle name="Pattern.iterBack" h={0} />

## ply

<JsDoc client:idle name="ply" h={0} />

## segment

<JsDoc client:idle name="segment" h={0} />

## compress

<JsDoc client:idle name="compress" h={0} />

## zoom

<JsDoc client:idle name="zoom" h={0} />

## linger

<JsDoc client:idle name="linger" h={0} />

## fastGap

<JsDoc client:idle name="fastGap" h={0} />

## inside

<JsDoc client:idle name="inside" h={0} />

## outside

<JsDoc client:idle name="outside" h={0} />

## cpm

<JsDoc client:idle name="cpm" h={0} />

## ribbon

<JsDoc client:idle name="ribbon" h={0} />

## swingBy

<JsDoc client:idle name="swingBy" h={0} />

## swing

<JsDoc client:idle name="swing" h={0} />

Apart from modifying time, there are ways to [Control Parameters](/functions/value-modifiers/).


---
title: Tonal Functions
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Tonal Functions

These functions use [tonaljs](https://github.com/tonaljs/tonal) to provide helpers for musical operations.

### voicing()

<JsDoc client:idle name="voicing" h={0} />

Here's an example of how you can play chords and a bassline:

<MiniRepl
  client:idle
  tune={`chord("<C^7 A7b13 Dm7 G7>*2")
  .dict('ireal').layer(
  x=>x.struct("[~ x]*2").voicing()
  ,
  x=>n("0*4").set(x).mode("root:g2").voicing()
  .s('sawtooth').cutoff("800:4:2")
)`}
/>

### scale(name)

<JsDoc client:idle name="scale" h={0} />

### transpose(semitones)

Transposes all notes to the given number of semitones:

<MiniRepl client:only="react" tune={`"[c2 c3]*4".transpose("<0 -2 5 3>").note()`} />

This method gets really exciting when we use it with a pattern as above.

Instead of numbers, scientific interval notation can be used as well:

<MiniRepl client:only="react" tune={`"[c2 c3]*4".transpose("<1P -2M 4P 3m>").note()`} />

### scaleTranspose(steps)

Transposes notes inside the scale by the number of steps:

<MiniRepl
  client:idle
  tune={`"[-8 [2,4,6]]*2"
.scale('C4 bebop major')
.scaleTranspose("<0 -1 -2 -3 -4 -5 -6 -4>*2")
.note()`}
/>

### rootNotes(octave = 2)

Turns chord symbols into root notes of chords in given octave.

<MiniRepl client:only="react" tune={`"<C^7 A7b13 Dm7 G7>*2".rootNotes(3).note()`} />

Together with layer, struct and voicings, this can be used to create a basic backing track:

<MiniRepl
  client:idle
  tune={`"<C^7 A7b13 Dm7 G7>*2".layer(
  x => x.voicings('lefthand').struct("[~ x]*2").note(),
  x => x.rootNotes(2).note().s('sawtooth').cutoff(800)
)`}
/>


---
title: Visual Feedback
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Visual Feedback

There are several function that add visual feedback to your patterns.

## Mini Notation Highlighting

When you write mini notation with "double quotes" or \`backticks\`, the active parts of the mini notation will be highlighted:

<MiniRepl
  client:idle
  tune={`n("<0 2 1 3 2>*8")
.scale("<A1 D2>/4:minor:pentatonic")
.s("supersaw").lpf(300).lpenv("<4 3 2>\*4")`}
/>

You can change the color as well, even pattern it:

<MiniRepl
  client:idle
  tune={`n("<0 2 1 3 2>*8")
.scale("<A1 D2>/4:minor:pentatonic")
.s("supersaw").lpf(300).lpenv("<4 3 2>*4")
.color("cyan magenta")`}
/>

## Global vs Inline Visuals

The following functions all come with in 2 variants.

**Without prefix**: renders the visual to the background of the page:

<MiniRepl client:idle tune={`note("c a f e").color("white").punchcard()`} />

**With `_` prefix**: renders the visual inside the code. Allows for multiple visuals

<MiniRepl client:idle tune={`note("c a f e").color("white")._punchcard()`} />

Here we see the 2 variants for `punchcard`. The same goes for all others below.
To improve readability the following demos will all use the inline variant.

## Punchcard / Pianoroll

These 2 functions render a pianoroll style visual.
The only difference between the 2 is that `pianoroll` will render the pattern directly,
while `punchcard` will also take the transformations into account that occur afterwards:

<MiniRepl
  client:idle
  tune={`note("c a f e").color("white")
._punchcard()
.color("cyan")`}
  autodraw
/>

Here, the `color` is still visible in the visual, even if it is applied after `_punchcard`.
On the contrary, the color is not visible when using `_pianoroll`:

<MiniRepl
  client:idle
  tune={`note("c a f e").color("white")
._pianoroll()
.color("cyan")`}
  autodraw
/>

import Box from '@components/Box.astro';

<br />

<Box>

`punchcard` is less resource intensive because it uses the same data as used for the mini notation highlighting.

</Box>

The visual can be customized by passing options. Those options are the same for both functions.

What follows is the API doc of all the options you can pass:

<JsDoc client:idle name="pianoroll" h={0} />

## Spiral

<JsDoc client:idle name="spiral" h={0} />

## Scope

<JsDoc client:idle name="scope" h={0} />

## Pitchwheel

<JsDoc client:idle name="pitchwheel" h={0} />

## Spectrum

<JsDoc client:idle name="spectrum" h={0} />

## markcss

<JsDoc client:idle name="markcss" h={0} />


---
title: Xen Harmonic Functions
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Xen Harmonic Functions

These functions allow the use of scales other than your typical chromatic 12 based ones.

### tune(scale)

<JsDoc client:idle name="tune" h={0} />

Here's an example of how to configure a basic hexany scale:

<MiniRepl client:idle tune={`"0 1 2 3 4 5".tune("hexany15").mul("220").freq()`} />

Try other scales like `hexany1`, `iraq`, `gumbeng`, `gunkali`, or `tranh3`

For a full list of available scales from tunejs, see http://abbernie.github.io/tune/scales.html

You can set your root to be a particular note with `getFreq`

<MiniRepl
  client:idle
  tune={`"4 8 9 10 - - 5 7 9 11 - -".tune("tranh3")
    .mul(getFreq('c3'))
    .freq().clip(.5).room(1)`}
/>

Some tunings become more pronounced with a longer reverb decay:

<MiniRepl
  client:idle
  tune={`"<[5 6 8 10] - [5 7 9 12] -> -".tune("gumbeng")
  .mul(getFreq('c3'))
  .freq().clip(.8).room("3:10").rdim(10000).rfade(5)`}
/>

Additionally, you can combo this with `fmap` so that the base note changes:

<MiniRepl
  client:idle
  tune={`"9 11 12 10 - - -".tune("gunkali")
  .mul("<c3 c3 a3 d#3>".fmap(getFreq))
  .freq().legato("2 .7").room("1:15").rdim(8500).rlp(14000).rfade(8)`}
/>

Combining this with various polyrhythm tricks can become very evocative:

<MiniRepl
  client:idle
  tune={`"<[0 3 1 -] [-1 4 2 8]> ~ ~,<-4 -5>"
  .transpose(4)
  .tune("iraq")
  .mul("<c3 d3 c#3>".fmap(getFreq))
  .freq().clip(.5).room(1).rfade(9)`}
/>

Another helpful trick when exploring new tunings is to strum them.
Many have a much more enchanting sound that was chosen over many generations of musicians for being strummed.

Take the `sanza` tuning:

<MiniRepl
  client:idle
  tune={`"4 5 6 7 8 9".tune("sanza")
  .mul(getFreq('c3'))
  .freq()`}
/>

Notes 7 and 9 will clash quite a bit if you arp them normally. Many tunings will have this sort of sound, and it can feel distracting on its own.
See how close they are on the pitch wheel?

<MiniRepl client:idle tune={`"[7 9]!3".tune("sanza").mul(getFreq('c3')).freq()._pitchwheel()`} />

This quality is often due to how the tunings were formed with instruments that were played differently than a piano.
As such, some tunings are much better strummed, with the subtle clash of the detuned notes actually making the sound much more magical:

<MiniRepl
  client:idle
  tune={`"[0 1 2 3 4 5 6]@0.3 -"
  .transpose("<2 5 8 1>")
  .tune("sanza")
  .mul(getFreq('c3')).freq()
  .legato("3").room(1).rfade(5)`}
/>

Note the legato and reverb effects make sure the sound of the strumming gets to wash together. Alternating the direction of the strum can make the
tones sound even more alive, too.

The `tranh3` tuning has a similar set of notes, with two clashing. You might trying plugging that in above and see if you find a favorite strumming pattern.


---
title: Build Arpeggios
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

Note: This has been (partly) translated from https://tidalcycles.org/docs/patternlib/howtos/buildarpeggios

# Build Arpeggios

This page will teach you how to get started writing arpeggios using different techniques. It is a good way to learn Strudel in a more intuitive way.

## Arpeggios from notes

Start with a simple sequence of notes:

<MiniRepl tune={`note("c a f e").piano().slow(2)`} client:idle />

Now, let's play one per cycle:

<MiniRepl tune={`note("<c a f e>").piano().slow(2)`} client:idle />

On top of that, put a copy of the sequence, offset in time and pitch:

<MiniRepl
  tune={`"<c a f e>".off(1/8, add(7))
  .note().piano().slow(2)`}
  client:idle
/>

Add some structure to the original sequence:

<MiniRepl
  tune={`"<c*2 a(3,8) f(3,8,2) e*2>"
  .off(1/8, add(7))
  .note().piano().slow(2)`}
  client:idle
/>

Reverse in one speaker:

<MiniRepl
  tune={`"<c*2 a(3,8) f(3,8,2) e*2>"
  .off(1/8, add(7))
  .note().piano()
  .jux(rev).slow(2)`}
  client:idle
/>

Let's add another layer:

<MiniRepl
  tune={`"<c*2 a(3,8) f(3,8,2) e*2>"
  .off(1/8, add(7))
  .off(1/8, add(12))
  .note().piano()
  .jux(rev).slow(2)`}
  client:idle
/>

- added slow(2) to approximate tidals cps
- n was replaced with note, because using n does not work as note for samples
- legato 2 was removed because it does not work in combination with rev (bug)

## Arpeggios from chords

TODO


---
title: Microrhythms
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

see https://strudel.cc/?zMEo5kowGrFc

# Microrhythms

Inspired by this [Mini-Lecture on Microrhythm Notation](https://www.youtube.com/watch?v=or7B6vI3jOo), let's look at how we can express microrhythms with Strudel.

The timestamps of the first rhythm are `0 1/5 1/2 2/3 1`. We could naively express this with a stack:

<MiniRepl
  client:idle
  tune={`s("hh").struct(
  stack(
    "x", // 0
    "~ x ~@3", // 1/5
    "~ x", // 1/2
    "~@2 x" // 2/3
))`}
/>

While this works, it has two problems:

- it is not very compact
- the durations are wrong, e.g. the first note takes up the whole cycle

In the video, the duration of a timestamp is calculated by subtracting it from the next timestamp:

- 1/5 - 0 = 1/5 = 6/30
- 1/2 - 1/5 = 3/10 = 9/30
- 2/3 - 1/2 = 1/6 = 5/30
- 1 - 2/3 = 1/3 = 10/30

Using those, we can now express the rhythm much shorter:

<MiniRepl client:idle tune={`s("hh").struct("x@6 x@9 x@5 x@10")`} />

The problems of the first notation are now fixed: it is much shorter and the durations are correct.
Still, this notation involved calculating the durations by hand, which could be automated:

<MiniRepl
  client:idle
  tune={`Pattern.prototype.micro = function (...timestamps) {
  const durations = timestamps.map((x, i, a) => {
    const next = i < a.length-1 ? a[i+1] : 1;
    return next - a[i]
  })
  return this.struct(timeCat(...durations.map(d => [d, 1]))).late(timestamps[0])
}
s('hh').micro(0, 1/5, 1/2, 2/3)`}
/>

This notation is even shorter and it allows directly filling in the timestamps!

This is the second example of the video:

<MiniRepl
  client:idle
  tune={`Pattern.prototype.micro = function (...timestamps) {
  const durations = timestamps.map((x, i, a) => {
    const next = i < a.length-1 ? a[i+1] : 1;
    return next - a[i]
  })
  return this.struct(timeCat(...durations.map(d => [d, 1]))).late(timestamps[0])
}
s('hh').micro(0, 1/6, 2/5, 2/3, 3/4)`}
/>

with bass: https://strudel.cc/?sTglgJJCPIeY


---
title: Recipes
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Recipes

This page shows possible ways to achieve common (or not so common) musical goals.
There are often many ways to do a thing and there is no right or wrong.
The fun part is that each representation will give you different impulses when improvising.

## Arpeggios

An arpeggio is when the notes of a chord are played in sequence.
We can either write the notes by hand:

<MiniRepl
  client:visible
  tune={`note("c eb g c4")
.clip(2).s("gm_electric_guitar_clean")`}
  punchcard
/>

...or use scales:

<MiniRepl
  client:visible
  tune={`n("0 2 4 7").scale("C:minor")
.clip(2).s("gm_electric_guitar_clean")`}
  punchcard
/>

...or chord symbols:

<MiniRepl
  client:visible
  tune={`n("0 1 2 3").chord("Cm").mode("above:c3").voicing()
.clip(2).s("gm_electric_guitar_clean")`}
  punchcard
/>

...using off:

<MiniRepl
  client:visible
  tune={`"0"
  .off(1/3, add(2))
  .off(1/2, add(4))
  .n()
  .scale("C:minor")
  .s("gm_electric_guitar_clean")`}
  punchcard
/>

## Chopping Breaks

A sample can be looped and chopped like this:

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen/4").fit().chop(32)`}
  punchcard
/>

This fits the break into 8 cycles + chops it in 16 pieces.
The chops are not audible yet, because we're not doing any manipulation.
Let's add randmized doubling + reversing:

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen/4").fit().chop(16).cut(1)
.sometimesBy(.5, ply("2"))
.sometimesBy(.25, mul(speed("-1")))`}
  punchcard
/>

If we want to specify the order of samples, we can replace `chop` with `slice`:

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen/4").fit()
  .slice(8, "<0 1 2 3 4*2 5 6 [6 7]>*2")
  .cut(1).rarely(ply("2"))`}
  punchcard
/>

If we use `splice` instead of `slice`, the speed adjusts to the duration of the event:

<MiniRepl
  client:visible
  tune={`samples('github:yaxu/clean-breaks')
s("amen")
  .splice(8, "<0 1 2 3 4*2 5 6 [6 7]>*2")
  .cut(1).rarely(ply("2"))`}
  punchcard
/>

Note that we don't need `fit`, because `splice` will do that by itself.

## Filter Envelopes

Using `lpenv`, we can make the filter move:

<MiniRepl
  client:visible
  tune={`note("g1 bb1 <c2 eb2> d2")
  .s("sawtooth")
  .lpf(400).lpenv(4)
  .scope()`}
/>

The type of envelope depends on the methods you're setting. Let's set `lpa`:

<MiniRepl
  client:visible
  tune={`note("g1 bb1 <c2 eb2> d2")
  .s("sawtooth").lpq(8)
  .lpf(400).lpa(.2).lpenv(4)
  .scope()`}
/>

Now the filter is attacking, rather than decaying as before (decay is the default). We can also do both

<MiniRepl
  client:visible
  tune={`note("g1 bb1 <c2 eb2> d2")
  .s("sawtooth").lpq(8)
  .lpf(400).lpa(.1).lpd(.1).lpenv(4)
  .scope()`}
/>

You can play around with `lpa` | `lpd` | `lps` | `lpd` to see what the filter envelope will do.

## Layering Sounds

We can layer sounds by separating them with ",":

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>")
.s("sawtooth, square") // <------
.scope()`}
/>

We can control the gain of individual sounds like this:

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>")
.s("sawtooth, square:0:.5") // <--- "name:number:gain"
.scope()`}
/>

For more control over each voice, we can use `layer`:

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>").layer(
  x=>x.s("sawtooth").vib(4),
  x=>x.s("square").add(note(12))
).scope()`}
/>

Here, we give the sawtooth a vibrato and the square is moved an octave up.
With `layer`, you can use any pattern method available on each voice, so sky is the limit..

## Oscillator Detune

We can fatten a sound by adding a detuned version to itself:

<MiniRepl
  client:visible
  tune={`note("<g1 bb1 d2 f1>")
.add(note("0,.1")) // <------ chorus
.s("sawtooth").scope()`}
  punchcard
/>

Try out different values, or add another voice!

## Polyrhythms

Here is a simple example of a polyrhythm:

<MiniRepl client:visible tune={`s("bd*2,hh*3")`} punchcard />

A polyrhythm is when 2 different tempos happen at the same time.

## Polymeter

This is a polymeter:

<MiniRepl client:visible tune={`s("<bd rim, hh hh oh>*4")`} punchcard />

A polymeter is when 2 different bar lengths play at the same tempo.

## Phasing

This is a phasing:

<MiniRepl client:visible tune={`note("<C D G A Bb D C A G D Bb A>*[6,6.1]").piano()`} punchcard />

Phasing happens when the same sequence plays at slightly different tempos.

## Running through samples

Using `run` with `n`, we can rush through a sample bank:

<MiniRepl
  client:visible
  tune={`samples('bubo:fox')
n(run(8)).s("ftabla")`}
  punchcard
/>

This works great with sample banks that contain similar sounds, like in this case different recordings of a tabla.
Often times, you'll hear the beginning of the phrase not where the pattern begins.
In this case, I hear the beginning at the third sample, which can be accounted for with `early`.

<MiniRepl
  client:visible
  tune={`samples('bubo:fox')
n(run(8)).s("ftabla").early(2/8)`}
/>

Let's add some randomness:

<MiniRepl
  client:visible
  tune={`samples('bubo:fox')
n(run(8)).s("ftabla").early(2/8)
.sometimes(mul(speed("1.5")))`}
/>

## Tape Warble

We can emulate a pitch warbling effect like this:

<MiniRepl
  client:visible
  tune={`note("<c4 bb f eb>*8")
.add(note(perlin.range(0,.5))) // <------ warble
.clip(2).s("gm_electric_guitar_clean")`}
/>

## Sound Duration

There are a number of ways to change the sound duration. Using clip:

<MiniRepl
  client:visible
  tune={`note("f ab bb c")
.clip("<2 1 .5 .25>")`}
/>

The value of clip is relative to the duration of each event.
We can also create overlaps using release:

<MiniRepl
  client:visible
  tune={`note("f ab bb c")
.release("<2 1 .5 .25>")`}
/>

This will smoothly fade out each sound for the given number of seconds.
We could also make the notes shorter by using a decay envelope:

<MiniRepl
  client:visible
  tune={`note("f ab bb c")
.decay("<2 1 .5 .25>")`}
/>

When using samples, we also have `.end` to cut relative to the sample length:

<MiniRepl client:visible tune={`s("oh*4").end("<1 .5 .25 .1>")`} />

Compare that to clip:

<MiniRepl client:visible tune={`s("oh*4").clip("<1 .5 .25 .1>")`} />

or decay:

<MiniRepl client:visible tune={`s("oh*4").decay("<1 .5 .25 .1>")`} />

## Wavetable Synthesis

You can loop a sample with `loop` / `loopEnd`:

<MiniRepl client:visible tune={`note("<c eb g f>").s("bd").loop(1).loopEnd(.05).gain(.2)`} />

This allows us to play the first 5% of the bass drum as a synth!
To simplify loading wavetables, any sample that starts with `wt_` will be looped automatically:

<MiniRepl
  client:visible
  tune={`samples('github:bubobubobubobubo/dough-waveforms')
note("c eb g bb").s("wt_dbass").clip(2)`}
/>

Running through different wavetables can also give interesting variations:

<MiniRepl
  client:visible
  tune={`samples('github:bubobubobubobubo/dough-waveforms')
note("c2*8").s("wt_dbass").n(run(8)).fast(2)`}
/>

...adding a filter envelope + reverb:

<MiniRepl
  client:visible
  tune={`samples('github:bubobubobubobubo/dough-waveforms')
note("c2*8").s("wt_dbass").n(run(8))
.lpf(perlin.range(100,1000).slow(8))
.lpenv(-3).lpa(.1).room(.5).fast(2)`}
/>


---
title: Build Rhythms
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

Note:

- this has been (partly) translated from https://tidalcycles.org/docs/patternlib/howtos/buildrhythms
- this only sounds good with `samples('github:tidalcycles/dirt-samples')` in prebake

# Build Rhythms

This page will teach you how to get started writing rhythms using different techniques. It is a good way to learn Strudel in a more intuitive way.

## From a simple to a complex rhythm

Simple bass drum - snare:

<MiniRepl client:idle tune={`s("bd sd").slow(2)`} />

Let's pick a different snare sample:

<MiniRepl client:idle tune={`s("bd sd:3").slow(2)`} />

Now, we are going to change the rhythm:

<MiniRepl client:idle tune={`s("bd*2 [~ sd:3]").slow(2)`} />

And add some toms:

<MiniRepl client:idle tune={`s("bd*2 [[~ lt] sd:3] lt:1 [ht mt*2]").slow(2)`} />

Start to transform, shift a quarter cycle every other cycle:

<MiniRepl
  client:idle
  tune={`s("bd*2 [[~ lt] sd:3] lt:1 [ht mt*2]")
.every(2, early(.25)).slow(2)`}
/>

Pattern the shift amount:

<MiniRepl
  client:idle
  tune={`s("bd*2 [[~ lt] sd:3] lt:1 [ht mt*2]")
.every(2, early("<.25 .125 .5>")).slow(2)`}
/>

Add some patterned effects:

<MiniRepl
  client:idle
  tune={`s("bd*2 [[~ lt] sd:3] lt:1 [ht mt*2]")
.every(2, early("<.25 .125 .5>"))
.shape("<0 .5 .3>")
.room(saw.range(0,.2).slow(4))
.slow(2)`}
/>

More transformation:

<MiniRepl
  client:idle
  tune={`s("bd*2 [[~ lt] sd:3] lt:1 [ht mt*2]")
.every(2, early("<.25 .125 .5>"))
.shape("<0 .5 .3>")
.room(saw.range(0,.2).slow(4))
.jux(id, rev, x=>x.speed(2))
.slow(2)`}
/>

## Another rhythmic construction

Let's start with a sequence:

<MiniRepl client:idle tune={`n("0 0 [2 0] [2 3]").s("feel").speed(1.5).slow(2)`} />

We add a bit of flavour:

<MiniRepl client:idle tune={`n("0 <0 4> [2 0] [2 3]").s("feel").speed(1.5).slow(2)`} />

Swap the samples round every other cycle:

TODO: implement `rot`


This section introduces you to Strudel in a technical sense. If you just want to _use_ Strudel, have a look at the [Tutorial](/workshop/getting-started).

TODO


---
title: Pattern Aligment
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Pattern Aligment & Combination

One core aspect of Strudel, inherited from Tidal, is the flexible way that patterns can be combined, irrespective of their structure. Its declarative approach means a live coder does not have to think about the details of _how_ this is done, only _what_ is to be done.

As a simple example, consider two number patterns `"0 [1 2] 3"`, and `"10 20"`. The first has three contiguous steps of equal lengths, with the second step broken down into two substeps, giving four events in total. There are a very large number of ways in which the structure of these two patterns could be combined, but the default method in both Strudel and Tidal is to line up the cycles of the two patterns, and then take events from the first pattern and match them with those in the second pattern. Therefore, the following two lines are equivalent:

```js
'0 [1 2] 3'.add('10 20');
('10 [11 22] 23');
```

Where the events only partially overlap, they are treated as fragments
of the event in the first pattern. This is a little difficult to
conceptualise, but lets start by comparing the two patterns in the
following example:

```js
'0 1 2'.add('10 20');
('10 [11 21] 22');
```

They are similar to the previous example in that the number `1` is split in two, with its two halves added to `10` and `20` respectively. However, the `11` 'remembers' that it is a fragment of that original `1` event, and so is treated as having a duration of a third of a cycle, despite only being active for a sixth of a cycle. Likewise, the `21` is also a fragment of that original `1` event, but a fragment of its second half. Because the start of its event is missing, it wouldn't actually trigger a sound (unless it underwent further pattern transformations/combinations).

In practice, the effect of this default, implicit method for combining two patterns is that the second pattern is added _in_ to the first one, and indeed this can be made explicit:

```js
'0 1 2'.add.in('10 20');
```

This makes way for other ways to align the pattern, and several are already defined, in particular:

- `in` - as explained above, aligns cycles, and applies values from the pattern on the right _in_ to the pattern on the left.
- `out` - as with `in`, but values are applied _out_ of the pattern on the left (i.e. _in_ to the one on the right).
- `mix` - structures from both patterns are combined, so that the new events are not fragments but are created at intersections of events from both sides.
- `squeeze` - cycles from the pattern on the right are squeezed into events on the left. So that e.g. `"0 1 2".add.squeeze("10 20")` is equivalent to `"[10 20] [11 21] [12 22]"`.
- `squeezeout` - as with `squeeze`, but cycles from the left are squeezed into events on the right. So, `"0 1 2".add.squeezeout("10 20")` is equivalent to `[10 11 12] [20 21 22]`.
- `reset` is similar to `squeezeout` in that cycles from the right are aligned with events on the left. However those cycles are not 'squeezed', rather they are truncated to fit the event. So `"0 1 2 3 4 5 6 7".add.reset("10 [20 30]")` would be equivalent to `10 11 12 13 20 21 30 31`. In effect, events on the right 'reset' cycles on the left.
- `restart` is similar to `reset`, but the pattern is 'restarted' from its very first cycle, rather than from the current cycle. `reset` and `restart` therefore only give different results where the leftmost pattern differs from one cycle to the next.

We will save going deeper into the background, design and practicalities of these alignment functions for future publications. However in the next section, we take them as a case study for looking at the different design affordances offered by Haskell to Tidal, and JavaScript to Strudel.

Ok, so how do Strudel and Tidal [compare](/learn/strudel-vs-tidal)?


---
title: Docs
layout: ../../layouts/MainLayout.astro
---

# Docs

The docs page is built ontop of astro's [docs site](https://github.com/withastro/astro/tree/main/examples/docs).

## Adding a new Docs Page

1. add a `.mdx` file in a path under `website/src/pages/`, e.g. [website/src/pages/learn/code.mdx](https://codeberg.org/uzu/strudel/src/branch/main/website/src/pages/learn/code.mdx) will be available under https://strudel.cc/learn/code/ (or locally under `http://localhost:4321/learn/code/`)
2. make sure to copy the top part of another existing docs page. Adjust the title accordingly
3. To add a link to the sidebar, add a new entry to `SIDEBAR` to [`config.ts`](https://codeberg.org/uzu/strudel/src/branch/main/website/src/config.ts)

## Using the Mini REPL

To add a Mini REPL, make sure to import:

```js
import { MiniRepl } from '../../docs/MiniRepl';
```

add a mini repl with

```jsx
<MiniRepl client:idle tune={`note("a3 c#4 e4 a4")`} />
```

- `client:idle` is required to tell astro that the repl should be interactive, see [Client Directive](https://docs.astro.build/en/reference/directives-reference/#client-directives)
- `tune`: be any valid pattern code
- `punchcard`: if added, a punchcard / pianoroll visualization is renderd
- `drawTime`: time window for drawing, defaults to `[0, 4]`
- `canvasHeight`: height of the canvas, defaults to 100px

See `mini-notation.mdx` for usage examples

## In-Source Documentation

You can add the in-source documentation for a function by using the `JsDoc` component. Import:

```js
import { JsDoc } from '../../docs/JsDoc';
```

Usage:

```jsx
<JsDoc client:idle name="bandf" h={0} />
```

- `name`: function name, as named with `@name` in jsdoc
- `h`: level of heading. `0` will hide the heading. Hiding it allows using a manual heading which results in a nav link being generated in the right sidebar.
- `hideDescription`: if set, the description will be hidden

### Writing jsdoc

Documentation is written with [jsdoc](https://jsdoc.app/) comments. Example:

```js
/**
 * Select a sound / sample by name.
 *
 * @name s
 * @param {string | Pattern} sound The sound / pattern of sounds to pick
 * @example
 * s("bd hh")
 *
 */
// implementation of s function
```

- Before each build, these comments will be rendered into `doc.json` using [jsdoc-json](https://www.npmjs.com/package/jsdoc-json) as a template
- To regenerate the `doc.json` file manually, run `npm run jsdoc-json`
- The file is used by the `JsDoc` component to find the documentation by name
- Also, it is used for the `examples.test.mjs` snapshot test

How does Strudel do its [Testing](/technical-manual/testing)?


---
title: Internals
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Internal Functions

These functions are more low level, probably not needed by the live coder.

# Haskell-style functor, applicative and monadic operations

## withValue

<JsDoc client:idle name="Pattern#withValue" h={0} />

## appWhole

<JsDoc client:idle name="Pattern#appWhole" h={0} />

## appBoth

<JsDoc client:idle name="Pattern#appBoth" h={0} />

## appLeft

<JsDoc client:idle name="Pattern#appLeft" h={0} />

## appRight

<JsDoc client:idle name="Pattern#appRight" h={0} />

## bindWhole

<JsDoc client:idle name="Pattern#bindWhole" h={0} />

## bind

<JsDoc client:idle name="Pattern#bind" h={0} />

## join

<JsDoc client:idle name="Pattern#join" h={0} />

## outerBind

<JsDoc client:idle name="Pattern#outerBind" h={0} />

## outerJoin

<JsDoc client:idle name="Pattern#outerJoin" h={0} />

## innerBind

<JsDoc client:idle name="Pattern#innerBind" h={0} />

## innerJoin

<JsDoc client:idle name="Pattern#innerJoin" h={0} />

## resetJoin

<JsDoc client:idle name="Pattern#resetJoin" h={0} />

## restartJoin

<JsDoc client:idle name="Pattern#restartJoin" h={0} />

## squeezeJoin

<JsDoc client:idle name="Pattern#squeezeJoin" h={0} />

## squeezeBind

<JsDoc client:idle name="Pattern#squeezeBind" h={0} />

# Utility methods mainly for internal use

## queryArc

<JsDoc client:idle name="Pattern#queryArc" h={0} />

## splitQueries

<JsDoc client:idle name="Pattern#splitQueries" h={0} />

## withQuerySpan

<JsDoc client:idle name="Pattern#withQuerySpan" h={0} />

## withQuerySpanMaybe

<JsDoc client:idle name="Pattern#withQuerySpanMaybe" h={0} />

## withQueryTime

<JsDoc client:idle name="Pattern#withQueryTime" h={0} />

## withHapSpan

<JsDoc client:idle name="Pattern#withHapSpan" h={0} />

## withHapTime

<JsDoc client:idle name="Pattern#withHapTime" h={0} />

## withHaps

<JsDoc client:idle name="Pattern#withHaps" h={0} />

## withHap

<JsDoc client:idle name="Pattern#withHap" h={0} />

## setContext

<JsDoc client:idle name="Pattern#setContext" h={0} />

## withContext

<JsDoc client:idle name="Pattern#setContext" h={0} />

## stripContext

<JsDoc client:idle name="Pattern#stripContext" h={0} />

## withLoc

<JsDoc client:idle name="Pattern#withLoc" h={0} />

## filterHaps

<JsDoc client:idle name="Pattern#filterHaps" h={0} />

## filterValues

<JsDoc client:idle name="Pattern#filterValues" h={0} />

## removeUndefineds

<JsDoc client:idle name="Pattern#filterValues" h={0} />

## onsetsOnly

<JsDoc client:idle name="Pattern#onsetsOnly" h={0} />

## discreteOnly

<JsDoc client:idle name="Pattern#discreteOnly" h={0} />

## defragmentHaps

<JsDoc client:idle name="Pattern#defragmentHaps" h={0} />

## firstCycle

<JsDoc client:idle name="Pattern#firstCycle" h={0} />

## firstCycleValues

<JsDoc client:idle name="Pattern#firstCycleValues" h={0} />

## showFirstCycle

<JsDoc client:idle name="Pattern#showFirstCycle" h={0} />

## sortHapsByPart

<JsDoc client:idle name="Pattern#sortHapsByPart" h={0} />

## asNumber

<JsDoc client:idle name="Pattern#sortHapsByPart" h={0} />

# Operators

- \_opIn
- \_opOut
- \_opMix
- \_opSqueeze
- \_opSqueezeOut
- \_opTrig
- \_opTrigzero

# Other

## onTrigger

<JsDoc client:idle name="Pattern#onTrigger" h={0} />

## log

<JsDoc client:idle name="Pattern#log" h={0} />

## logValues

<JsDoc client:idle name="Pattern#logValues" h={0} />

## drawLine

<JsDoc client:idle name="Pattern#drawLine" h={0} />

## collect

# Functions

## groupHapsBy

<JsDoc client:idle name="groupHapsBy" h={0} />

## pure

<JsDoc client:idle name="pure" h={0} />

## reify

<JsDoc client:idle name="reify" h={0} />

## slowcatPrime

<JsDoc client:idle name="slowcatPrime" h={0} />

## isPattern

<JsDoc client:idle name="isPattern" h={0} />

## register

<JsDoc client:idle name="register" h={0} />

## toBipolar

<JsDoc client:idle name="toBipolar" h={0} />

## fromBipolar

<JsDoc client:idle name="fromBipolar" h={0} />

## compressSpan

<JsDoc client:idle name="compressSpan" h={0} />

## focus

<JsDoc client:idle name="focus" h={0} />

## focusSpan

## \_composeOp

# Composers

```
set keep keepif add sub mul div mod pow band bor bxor blshift brshift lt gt lte gte eq eqt ne net and or func
```

```
In Out Mix Squeeze SqueezeOut Trig Trigzero
```


---
title: Strudel Packages
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Strudel Packages

The [strudel repo](https://codeberg.org/uzu/strudel) is organized as a monorepo, containing multiple npm packages.
The purpose of the multiple packages is to

- organize the codebase into more modular, encapsulated pieces
- be able to opt out of certain functionalities
- keep the dependencies of the core packages small

## Overview

[See the latest published packages on npm](https://www.npmjs.com/search?q=%40strudel).
Here is an overview of all the packages:

### Umbrella Packages

These packages give you a batteries-included point of getting started, and most likely the thing you'd want to use in your project:

- [repl](https://codeberg.org/uzu/strudel/src/branch/main/packages/repl): The Strudel REPL as a web component.
- [web](https://codeberg.org/uzu/strudel/src/branch/main/packages/web): Strudel library for the browser, without UI.

To find out more about these two, read [Using Strudel in Your Project](/technical-manual/project-start)

### Essential Packages

These package are the most essential. You might want to use all of those if you're using strudel in your project:

- [core](https://codeberg.org/uzu/strudel/src/branch/main/packages/core#strudelcore): tidal pattern engine with core primitives
- [mini](https://codeberg.org/uzu/strudel/src/branch/main/packages/mini#strudelmini): mini notation parser + core bindings
- [transpiler](https://codeberg.org/uzu/strudel/src/branch/main/packages/transpiler#strudeltranspiler): user code transpiler. syntax sugar + highlighting

### Language Extensions

These packages extend the pattern language by specific functions

- [tonal](https://codeberg.org/uzu/strudel/src/branch/main/packages/tonal): tonal functions for scales and chords
- [xen](https://codeberg.org/uzu/strudel/src/branch/main/packages/xen): microtonal / xenharmonic functions

### Outputs

These packages provide bindings for different ways to output strudel patterns:

- [webaudio](https://codeberg.org/uzu/strudel/src/branch/main/packages/webaudio#strudelwebaudio): the default webaudio output
- [osc](https://codeberg.org/uzu/strudel/src/branch/main/packages/osc#strudelosc): bindings to communicate via OSC
- [midi](https://codeberg.org/uzu/strudel/src/branch/main/packages/midi#strudelmidi): webmidi bindings
- [csound](https://codeberg.org/uzu/strudel/src/branch/main/packages/csound#strudelcsound): csound bindings
- [soundfonts](https://codeberg.org/uzu/strudel/src/branch/main/packages/serial#strudelsoundfonts): Soundfont support
- [serial](https://codeberg.org/uzu/strudel/src/branch/main/packages/serial#strudelserial): webserial bindings

### Others

- [embed](https://codeberg.org/uzu/strudel/src/branch/main/packages/embed#strudelembed): embeddable REPL web component

### No Longer Maintained

- [react](https://www.npmjs.com/package/@strudel.cycles/react): react hooks and components for strudel
- [eval](https://www.npmjs.com/package/@strudel.cycles/eval): old code transpiler
- [tone](https://www.npmjs.com/package/@strudel.cycles/tone): bindings for Tone.js instruments and effects
- [webdirt](https://www.npmjs.com/package/@strudel.cycles/webdirt): webdirt bindings, replaced by webaudio package
- any `@strudel.cycles/*` packages have been renamed to `@strudel/*` since version 0.10.0.

## Tools

- [pnpm](https://pnpm.io/) for package management, workspaces and publishing
- [lerna](https://lerna.js.org/) for bumping versions
- see CONTRIBUTING.md for more info


---
title: Patterns
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Patterns

Patterns are the essence of Tidal. Its patterns are abstract entities that represent flows of time as functions, adapting a technique called pure functional reactive programming. Taking a time span as its input, a Pattern can output a set of events that happen within that time span. It depends on the structure of the Pattern how the events are located in time.
From now on, this process of generating events from a time span will be called **querying**.
Example:

<MiniRepl
  client:idle
  tune={`const pattern = sequence("c3", ["e3", "g3"])
const events = pattern.queryArc(0, 1)
console.log(events.map((e) => e.show()))
silence`}
/>

In this example, we create a pattern using the `sequence` function and **query** it for the time span from `0` to `1`.
Those numbers represent units of time called **cycles**. The length of one cycle depends on the tempo, which defaults to one cycle per second.
The resulting events are:

```js
[
  '[ 0/1 -> 1/2 | c3 ]', //
  '[ 1/2 -> 3/4 | e3 ]',
  '[ 3/4 -> 1/1 | g3 ]',
];
```

Each event has a value, a begin time and an end time, where time is represented as a fraction. In the above case, the events are placed in sequential order, where c3 takes the first half, and e3 and g3 together take the second half. This temporal placement is the result of the `sequence` function, which divides its arguments equally over one cycle. If an argument is an array, the same rule applies to that part of the cycle. In the example, e3 and g3 are divided equally over the second half of the whole cycle.

Note that the query function is not just a way to access a pattern, but true to the principles of functional programming, is the pattern itself. This means that in theory there is no way to change a pattern, it is opaque as a pure function. In practice though, Strudel and Tidal are all about transforming patterns, so how is this done? The answer is, by replacing the pattern with a new one, that calls the old one. This new one is only able to manipulate the query before passing it to the old pattern, and manipulate the results from it before returning them to caller. But, this is enough to support all the temporal and structural manipulations provided by Strudel (and Tidal's) extensive library of functions.

The above examples do not represent how Strudel is used in practice. In the live coding editor, the user only has to type in the pattern itself, the querying will be handled by the scheduler. The scheduler will repeatedly query the pattern for events, which are then scheduled as sound synthesis or other event triggers.

Can we [align](/technical-manual/alignment) patterns?


---
title: Using Strudel in your Project
layout: ../../layouts/MainLayout.astro
---

# Using Strudel in your Project

This Guide shows you the different ways to get started with using Strudel in your own project.

## Respect the license

First, please take a moment to understand Strudel's free/open source license,
[AGPL-3.0](https://www.gnu.org/licenses/agpl-3.0.en.html).

Here is a lay summary, but check the license for legal definitions and responsibilities.

- You can distribute modified versions if you keep track of the changes and the date you made them.
- You must license derivative work under the same license.
- Source code must be distributed along with web publication.

Among other things, it means that when you share your work, the whole application must be shared under the same free/open source license, or one compatible with it. This is because we want Strudel to stay free/open source. In other words, you are not permitted to distribute integrations of Strudel with libraries or other code that does not have a compatible free/open source license.

This also applies to clones informed by reading Strudel's source code, as legally speaking, that counts as a 'derivative work'. Again, please [read the licence](https://www.gnu.org/licenses/agpl-3.0.en.html) for details.

## Embedding the Strudel REPL

There are 3 quick ways to embed strudel in your website:

1. Embed the strudel website as an iframe directly
2. Embed the strudel website as an iframe using `@strudel/embed`
3. Embed the REPL directly using `@strudel/repl`

### Inside an iframe

Using an iframe is the most easy way to embed a strudel tune.
You can embed any pattern of your choice via an iframe and the URL of the pattern of your choice:

```html
<iframe src="https://strudel.cc/?xwWRfuCE8TAR" width="600" height="300"></iframe>
```

The URL can be obtained by pressing `share` in the REPL.
Note that these share links depend on a database, which is not guaranteed to live forever.
To make sure your code is not lost, you can also use the long url:

```html
<iframe
  src="https://strudel.cc/#c2V0Y3BzKDEpCm4oIjwwIDEgMiAzIDQ%2BKjgiKS5zY2FsZSgnRzQgbWlub3InKQoucygiZ21fbGVhZF82X3ZvaWNlIikKLmNsaXAoc2luZS5yYW5nZSguMiwuOCkuc2xvdyg4KSkKLmp1eChyZXYpCi5yb29tKDIpCi5zb21ldGltZXMoYWRkKG5vdGUoIjEyIikpKQoubHBmKHBlcmxpbi5yYW5nZSgyMDAsMjAwMDApLnNsb3coNCkp"
  width="600"
  height="300"
></iframe>
```

That long URL can just be copy pasted from the URL bar when you're on the strudel website. It always reflects the latest evaluation of your code.

### @strudel/embed

To simplify the process of emebdding via an iframe, you can use the package `@strudel/embed`:

```html
<script src="https://unpkg.com/@strudel/embed@latest"></script>
<strudel-repl>
  <!--
setcps(1)
n("<0 1 2 3 4>*8").scale('G4 minor')
.s("gm_lead_6_voice")
.clip(sine.range(.2,.8).slow(8))
.jux(rev)
.room(2)
.sometimes(add(note("12")))
.lpf(perlin.range(200,20000).slow(4))
-->
</strudel-repl>
```

This will load the strudel website in an iframe, using the code provided within the HTML comments `<!-- -->`.
The HTML comments are needed to make sure the browser won't interpret it as HTML.

For alternative ways to load this package, see the [@strudel/embed README](https://codeberg.org/uzu/strudel/src/branch/main/packages/embed#strudel-embed).

### @strudel/repl

Loading strudel directly in your site, without an iframe, looks similar to the iframe variant:

```html
<script src="https://unpkg.com/@strudel/repl@latest"></script>
<strudel-editor>
  <!--
setcps(1)
n("<0 1 2 3 4>*8").scale('G4 minor')
.s("gm_lead_6_voice")
.clip(sine.range(.2,.8).slow(8))
.jux(rev)
.room(2)
.sometimes(add(note("12")))
.lpf(perlin.range(200,20000).slow(4))
-->
</strudel-editor>
```

Here, we're loading `@strudel/repl` instead of `@strudel/embed`, and the component is called `strudel-editor` instead of `strudel-repl`.
Yes the naming is a bit confusing..

The upside of using the repl without an iframe is that you can pin the strudel version you're using:

```html
<script src="https://unpkg.com/@strudel/repl@1.0.2"></script>
<strudel-editor>
  <!--
...  
-->
</strudel-editor>
```

This will guarantee your pattern wont break due to changes to the strudel project in the future.

For more info on this package, see the [@strudel/repl README](https://codeberg.org/uzu/strudel/src/branch/main/packages/repl#strudel-repl).

## With your own UI

The above approach assumes you want to use the builtin [codemirror](https://codemirror.net/) editor.
If you'd rather use your own UI, you can use the `@strudel/web` package:

```html
<!doctype html>
<script src="https://unpkg.com/@strudel/web@1.0.3"></script>
<button id="play">play</button>
<button id="stop">stop</button>
<script>
  initStrudel();
  document.getElementById('play').addEventListener('click', () => note('<c a f e>(3,8)').jux(rev).play());
  document.getElementById('stop').addEventListener('click', () => hush());
</script>
```

For more info on this package, see the [@strudel/web README](https://codeberg.org/uzu/strudel/src/branch/main/packages/web#strudel-web).

## Via npm

[All the packages and many more are available on npm under the @strudel namespace](https://www.npmjs.com/search?q=%40strudel).
There are actually many more packages you can use to have fine grained control over what you use and what not.
To use these packages, you have to use a bundler that supports es modules, like [vite](https://vitejs.dev/).

To find out more about the purpose of each package, see [Packages](/technical-manual/packages)


---
title: REPL
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# REPL

{/* The [REPL](https://strudel.cc/) is the place where all packages come together to form a live coding system. It can also be seen as a reference implementation for users of the library. */}

While Strudel can be used as a library in any JavaScript codebase, its main, reference user interface is the Strudel REPL[^1], which is a browser-based live coding environment. This live code editor is dedicated to manipulating Strudel patterns while they play. The REPL features built-in visual feedback, highlighting which elements in the patterned (mini-notation) sequences are influencing the event that is currently being played. This feedback is designed to support both learning and live use of Strudel.

[^1]: REPL stands for read, evaluate, print/play, loop. It is friendly jargon for an interactive programming interface from computing heritage, usually for a commandline interface but also applied to live coding editors.

Besides a UI for playback control and meta information, the main part of the REPL interface is the code editor powered by CodeMirror. In it, the user can edit and evaluate pattern code live, using one of the available synthesis outputs to create music and/or sound art. The control flow of the REPL follows 3 basic steps:

1. The user writes and updates code. Each update transpiles and evaluates it to create a `Pattern` instance
2. While the REPL is running, the `Scheduler` queries the active `Pattern` by a regular interval, generating `Events` (also known as `Haps` in Strudel) for the next time span.
3. For each scheduling tick, all generated `Events` are triggered by calling their `onTrigger` method, which is set by the output.

<img src="https://codeberg.org/uzu/strudel/raw/branch/talk/talk/public/strudelflow.png" width="600" />

## User Code

To create a `Pattern` from the user code, two steps are needed:

1. Transpile the JS input code to make it functional
2. Evaluate the transpiled code

### Transpilation & Evaluation

In the JavaScript world, using transpilation is a common practise to be able to use language features that are not supported by the base language. Tools like `babel` will transpile code that contains unsupported language features into a version of the code without those features.

In the same tradition, Strudel can add a transpilation step to simplify the user code in the context of live coding. For example, the Strudel REPL lets the user create mini-notation patterns using just double quoted strings, while single quoted strings remain what they are:

```strudel
note("c3 [e3 g3]*2")
```

is transpiled to:

```strudel
note(m('c3 [e3 g3]*2', 5))
```

Here, the string is wrapped in `m`, which will create a pattern from a mini-notation string. As the second parameter, it gets passed source code location of the string, which enables highlighting active events later.

After the transpilation, the code is ready to be evaluated into a `Pattern`.

Behind the scenes, the user code string is parsed with `acorn`, turning it into an Abstract Syntax Tree (AST). The AST allows changing the structure of the code before generating the transpiled version using `escodegen`.

### Mini-notation

While the transpilation allows JavaScript to express Patterns in a less verbose way, it is still preferable to use the mini-notation as a more compact way to express rhythm. Strudel aims to provide the same mini-notation features and syntax as used in Tidal.

The mini-notation parser is implemented using `peggy`, which allows generating performant parsers for Domain Specific Languages (DSLs) using a concise grammar notation. The generated parser turns the mini-notation string into an AST which is used to call the respective Strudel functions with the given structure. For example, `"c3 [e3 g3]*2"` will result in the following calls:

```strudel
seq(
  reify('c3').withLoc(6, 9),
  seq(reify('e3').withLoc(10, 12), reify('g3',).withLoc(13, 15))
)
```

### Highlighting Locations

As seen in the examples above, both the mini-notation parser adds the source code locations using `withLoc`.
This location is calculated inside the `m` function, as the sum of 2 locations:

1. the location where the mini notation string begins, as obtained from the JS parser
2. the location of the substring inside the mini notation, as obtained from the mini notation parser

The sum of both is passed to `withLoc` to tell each element its location, which can be later used for highlighting when it's active.

### Mini Notation

Another important part of the user code is the mini notation, which allows to express rhythms in a short manner.

- the mini notation is [implemented as a PEG grammar](https://codeberg.org/uzu/strudel/src/branch/talk/packages/mini/krill.pegjs), living in the [mini package](https://codeberg.org/uzu/strudel/src/branch/main/packages/mini)
- it is based on [krill](https://github.com/Mdashdotdashn/krill) by Mdashdotdashn
- the peg grammar is used to generate a parser with [peggyjs](https://peggyjs.org/)
- the generated parser takes a mini notation string and outputs an AST
- the AST can then be used to construct a pattern using the regular Strudel API

Here's an example AST for `c3 [e3 g3]`

```json
{
  "type_": "pattern",
  "arguments_": { "alignment": "h" },
  "source_": [
    {
      "type_": "element", "source_": "c3",
      "location_": { "start": { "offset": 1, "line": 1, "column": 2 }, "end": { "offset": 4, "line": 1, "column": 5 } }
    },
    {
      "type_": "element",
      "location_": { "start": { "offset": 4, "line": 1, "column": 5 }, "end": { "offset": 11, "line": 1, "column": 12 } }
      "source_": {
        "type_": "pattern", "arguments_": { "alignment": "h" },
        "source_": [
          {
            "type_": "element", "source_": "e3",
            "location_": { "start": { "offset": 5, "line": 1, "column": 6 }, "end": { "offset": 8, "line": 1, "column": 9 } }
          },
          {
            "type_": "element", "source_": "g3",
            "location_": { "start": { "offset": 8, "line": 1, "column": 9 }, "end": { "offset": 10, "line": 1, "column": 11 } }
          }
        ]
      },
    }
  ]
}
```

which translates to `seq(c3, seq(e3, g3))`

## Vim Keybindings

See the separate page on Vim shortcuts for a quick reference: [/technical-manual/vim](/technical-manual/vim)

## Scheduling Events

After an instance of `Pattern` is obtained from the user code,
it is used by the scheduler to get queried for events. Once started, the scheduler runs at a fixed interval to query the active pattern for events within the current interval's time span. A simplified implementation looks like this:

```js
let pattern = seq('c3', ['e3', 'g3']); // pattern from user
let interval = 0.5; // query interval in seconds
let time = 0; // beginning of current time span
let minLatency = 0.1; // min time before a hap should trigger
setInterval(() => {
  const haps = pattern.queryArc(time, time + interval);
  time += interval; // increment time
  haps.forEach((hap) => {
    const deadline = hap.whole.begin - time + minLatency;
    onTrigger(hap, deadline, duration);
  });
}, interval * 1000); // query each "interval" seconds
```

Note that the above code is simplified for illustrative purposes. The actual implementation has to work around imprecise callbacks of `setInterval`. More about the implementation details can be read in [this blog post](https://loophole-letters.vercel.app/web-audio-scheduling).

The fact that `Pattern.queryArc` is a pure function that maps a time span to a set of events allows us to choose any interval we like without changing the resulting output. It also means that when the pattern is changed from outside, the next scheduling callback will work with the new pattern, keeping its clock running.

The latency between the time the pattern is evaluated and the change is heard is between `minLatency` and `interval + minLatency`, in our example between 100ms and 600ms. In Strudel, the current query interval is 50ms with a minLatency of 100ms, meaning the latency is between 50ms and 150ms.

## Output

The last step is to trigger each event in the chosen output.
This is where the given time and value of each event is used to generate audio or any other form of time based output. The default output of the Strudel REPL is the WebAudio output. To understand what an output does, we first have to understand what control parameters are.

### Control Parameters

To be able to manipulate multiple aspects of sound in parallel, so called control parameters are used to shape the value of each event. Example:

```js
note('c3 e3')
  .cutoff(1000)
  .s('sawtooth')
  .queryArc(0, 1)
  .map((hap) => hap.value);
/* [
  { note: 'c3', cutoff: 1000, s: 'sawtooth' }
  { note: 'e3', cutoff: 1000, s: 'sawtooth' }
] */
```

Here, the control parameter functions `note`, `cutoff` and `s` are used, where each controls a different property in the value object. Each control parameter function accepts a primitive value, a list of values to be sequenced into a `Pattern`, or a `Pattern`. In the example, `note` gets a `Pattern` from a mini-notation expression (double quoted), while `cutoff` and `s` are given a `Number` and a (single quoted) `String` respectively.

Strudel comes with a large default set of control parameter functions that are based on the ones used by Tidal and SuperDirt, focusing on music and audio terminology. It is however possible to create custom control parameters for any purpose:

```js
const { x, y } = createParams('x', 'y');
x(sine.range(0, 200)).y(cosine.range(0, 200));
```

This example creates the custom control parameters `x` and `y` which are then used to form a pattern that descibes the coordinates of a circle.

### Outputs

Now that we know how the value of an event is manipulated using control parameters, we can look at how outputs can use that value to generate anything. The scheduler above was calling the `onTrigger` function which is used to implement the output. A very simple version of the web audio output could look like this:

```js
function onTrigger(hap, deadline, duration) {
  const { note } = hap.value;
  const time = getAudioContext().currentTime + deadline;
  const o = getAudioContext().createOscillator();
  o.frequency.value = getFreq(note);
  o.start(time);
  o.stop(time + event.duration);
  o.connect(getAudioContext().destination);
}
```

The above example will create an `OscillatorNode` for each event, where the frequency is controlled by the `note` param. In essence, this is how the WebAudio API output of Strudel works, only with many more parameters to control synths, samples and effects.

I want to help, how do I contribute to the [Docs](/technical-manual/docs)?


---
title: Sounds
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Sounds

Let's take a closer look about how sounds are implemented in the webaudio output.

## Registering a sound

All sounds are registered in the sound map, using the the `registerSound` function:

```js
function registerSound(
  name: string, // The name of the sound that should be given to `s`, e.g. `mysaw`
  // The function called by the scheduler to trigger the sound:
  (
    time: number, // The audio context time the sound should start
    value: object, // The value of the `Hap`
    onended: () => void // A callback that should be fired when the sound has ended
  ) => {
    node: AudioNode, // node to connect to rest of the effects chain
    stop: (time:number) => void // a function that will stop the sound
  },
  data: object // meta data, only for ui logic in sounds tab
);
```

When `registerSound` is called, it registers `{ onTrigger, data }` under the given `name` in a [nanostore map](https://github.com/nanostores/nanostores#maps).

### Example

This might be a bit abstract, so here is a minimal example:

<MiniRepl
  client:idle
  tune={`
  registerSound(
    'mysaw',
    (time, value, onended) => {
      let { freq } = value; // destructure control params
      const ctx = getAudioContext();
      // create oscillator
      const o = new OscillatorNode(ctx, { type: 'sawtooth', frequency: Number(freq) });
      o.start(time);
      // add gain node to level down osc
      const g = new GainNode(ctx, { gain: 0.3 });
      // connect osc to gain
      const node = o.connect(g);
      // this function can be called from outside to stop the sound
      const stop = (time) => o.stop(time);
      // ended will be fired when stop has been fired
      o.addEventListener('ended', () => {
        o.disconnect();
        g.disconnect();
        onended();
      });
      return { node, stop };
    },
    { type: 'synth' },
  );
  // use the sound
  freq("220 440 330").s('mysaw');`}
/>

You can actually use this code in the [REPL](https://strudel.cc/) and it'll work.
After evaluating the code, you should see `mysaw` in listed in the sounds tab.

## Playing sounds

Now here is what happens when a sound is played:
When the webaudio output plays a `Hap`, it will lookup and call the `onTrigger` function for the given `s`.
The returned `node` can then be connected to the rest of the standard effects chain
Having the stop function separate allows playing sounds via midi too, where you don't know how long the noteon will last


---
title: Testing
layout: ../../layouts/MainLayout.astro
---

# Testing

Strudel uses [vitest](https://vitest.dev/) for testing, with 2 types of testing strategies:

- unit tests for fine grained testing
- automated snapshot tests for broader testing

## Unit Tests

Each package has a `test` folder where tests are written on a file by file basis, e.g. `util.test.mjs` implements all tests for `util.mjs`.

## Snapshot Tests

Snapshot tests allow testing larger chunks of data. Strudel uses snapshot tests for:

- Example Snippets: `examples.test.mjs`, using snippets under `@example` inside jsdoc comments
- Example Tunes: `tunes.test.mjs`, using all patterns in `tunes.mjs`

The snapshot (`.snap`) files contain all haps within a certain number of cycles for each tested pattern.
They allow testing for breaking changes on a larger scale.
If breaking changes are intentional, the snapshots can be updated with `npm run snapshot`.
Just make sure to verify that all affected patterns behave as expected.


---
title: Vim Shortcuts
layout: ../../layouts/MainLayout.astro
---

# Vim Shortcuts in the REPL

When the REPL editor (CodeMirror) is configured to use Vim keybindings, the following commands are available:

- :w ‚Äî Evaluate the current code

  - Triggers the same evaluation as Ctrl+Enter / Alt+Enter
  - You'll see messages in the Console panel such as:
    - [vim] :w ‚Äî evaluating code
    - [repl] evaluate via event
    - [eval] code updated

- :q ‚Äî Stop/pause playback

  - Triggers the same stop action as Alt+.
  - Useful to quickly stop scheduling without leaving Vim mode

- gc ‚Äî Toggle line comments for the current selection(s)

  - Works in normal and visual mode
  - If there's a selection, all selected lines are toggled

Notes

- Behavior respects the current language mode in the editor for comment syntax.
- If multiple REPL editors are open, commands target the active editor. The implementation dispatches custom events handled by the editor.
- If you don't see the Console panel, open the right panel in the REPL UI.

Troubleshooting

- If :w logs but evaluation doesn't apply, ensure Vim keybindings are active and try again. You can also use Ctrl+Enter as a fallback.
- For :q / gc, ensure focus is inside the editor. If an error occurs, reload the page to reset editor state and try again.

## Adding custom keybindings

To add custom keybindings the `Vim` object can be used (either from within a pattern or in a prebake script)

Example:

```javascript
// Map 'jk' to Escape in normal mode
Vim.map('jk', '<Esc>', 'insert');
// Map 'U' to :w (Evaluate the current code)
Vim.map('U', ':w<CR>', 'normal');
// Map 'Q' to :q ‚Äî Stop/pause playback
Vim.map('Q', ':q<CR>', 'normal');
// Map 'J' to find next '$' (jump to next label)
Vim.map('J', '/\\$<CR>', 'normal');
// Map 'K' to find previous '$' (jump to previous label)
Vim.map('K', '?\\$<CR>', 'normal');
```

For more information on how to use the `Vim` object see [CodeMirror Vim](https://github.com/replit/codemirror-vim)


---
title: Understanding Cycles
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { PitchSlider } from '../../components/PitchSlider';
import Box from '@components/Box.astro';

# Understanding Cycles

The concept of cycles is very central to be able to understand how Strudel works.
Strudel's mother language, TidalCycles, even has it in its name.

## Cycles and BPM

In most music software, the unit BPM (beats per minute) is used to set the tempo.
Strudel expresses tempo as CPS (cycles per second), with a default of 0.5 CPS:

<MiniRepl client:visible tune={`s("bd")`} />

Here we can hear the 0.5CPS in action: The kick repeats once every two seconds.
Let's make it 4 kicks:

<MiniRepl client:visible tune={`s("bd bd bd bd")`} />

Now we have 4 kicks per cycle, but the whole pattern still plays at 0.5CPS.
In terms of BPM, most musicians would tell you this is playing at 120bpm.
What about this one:

<MiniRepl client:visible tune={`s("bd hh bd hh")`} />

Because the second sound is now a hihat, the tempo feels slower again.
This brings us to an important realization:

<Box>

Tempo is based on perception.
The choice of sounds also has an impact on the tempo feel.
This is why the same CPS can produce different perceived tempos.

</Box>

## Setting CPM

If you're familiar with BPM, you can use the `setcpm` method to set the global tempo in cycles per minute:

<MiniRepl
  client:visible
  tune={`setcpm(110)
s("bd hh")`}
/>

If you want to add more beats per cycle, you might want to divide the cpm:

<MiniRepl
  client:visible
  tune={`setcpm(110/4)
s("bd sd bd rim, hh*8")`}
/>

Or using 2 beats per cycle:

<MiniRepl
  client:visible
  tune={`setcpm(110/2)
s("bd sd, hh*4")`}
/>

You can use the `setcps` method to set the global tempo in cycles per second. `setcpm(x)` is the same as `setcps(x / 60)`.

<Box>

To set a specific bpm, use `setcpm(bpm/bpc)`

- bpm: the target beats per minute
- bpc: the number of perceived beats per cycle

</Box>

## Cycles and Bars

Also in most music software, multiple beats form a bar (or measure).
The so called time signature specifies how many beats are in each bar.
In many types of music, it is common to use 4 beats per bar, also known as 4/4 time.
Many music programs use it as a default.

Strudel does not a have concept of bars or measures, there are only cycles.
How you use them is up to you. Above, we've had this example:

<MiniRepl
  client:visible
  tune={`setcpm(110/4)
s("bd sd bd rim, hh*8")`}
/>

This could be interpreted as 4/4 time with a tempo of 110bpm.
We could write out multiple bars like this:

<MiniRepl
  client:visible
  tune={`setcpm(110/4)
s(\`<
[bd sd bd rim, hh*8] 
[bd sd bd rim*2, hh*8]
>\`)`}
/>

Instead of writing out each bar separately, we could express this much shorter:

<MiniRepl
  client:visible
  tune={`setcpm(110/2)
s("bd <sd rim*<1 2>>,hh*4")`}
/>

Here we can see that thinking in cycles rather than bars simplifies things a lot!
These types of simplifications work because of the repetitive nature of rhythm.
In computational terms, you could say the former notation has a lot of redundancy.

## Time Signatures

To get a time signature, just change the number of elements per bar. Here is a rhythm with 7 beats:

<MiniRepl client:visible tune={`s("bd ~ rim bd bd rim ~")`} />

or with 5:

<MiniRepl client:visible tune={`s("bd hh hh bd hh hh bd rim bd hh")`} />

We could also write multiple bars with different time signatures:

<MiniRepl
  client:visible
  tune={`setcpm(110*2)
s(\`<
[bd hh rim]@3
[bd hh rim sd]@4
>\`)`}
/>

Here we switch between 3/4 and 4/4, keeping the same tempo.

If we don't specify the length, we get what's called a metric modulation:

<MiniRepl
  client:visible
  tune={`setcpm(110/2)
s(\`<
[bd hh rim]
[bd hh rim sd]
>\`)`}
/>

Now the 3 elements get the same time as the 4 elements, which is why the tempo changes.


---
title: Understanding Pitch
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { PitchSlider } from '../../components/PitchSlider';
import Box from '@components/Box.astro';

# Understanding Pitch

Let's learn how pitch works! The slider below controls the <span style="color:#3b82f6;">frequency</span> of an oscillator, producing a pitch:

{/* <PitchSlider client:load showFrequencySlider plot /> */}

<PitchSlider client:load showFrequencySlider min={20} max={20000} />

- Drag the slider to hear a pitch
- Move the slider to change the pitch
- Observe how the Hz number changes
- <span className="text-red-300">Caution</span>: The higher frequencies could be disturbing for children or animals!

The Hz number is the frequency of the pitch you're hearing.
The higher the frequency, the higher the pitch and vice versa.
A pitch occurs whenever something is vibrating / oscillating at a frequency, in this case it's your speaker.
The unit **Hz** describes how many times that oscillation happens per second.
Our eyes are too slow to actually see the oscillation on the speaker, but we can <a href="https://www.youtube.com/watch?v=CDMBWw7OuJQ" target="_blank">see it in slow motion</a>.

<Box>

The hearing range of a newborn is said to be between 20Hz and 20000Hz.
The upper limit decreases with age. What's your upper limit?

</Box>

In Strudel, we can play frequencies directly with the `freq` control:

<MiniRepl client:visible tune={`freq("<200 [300,500] 400 [500,<600 670 712 670>]>*8")`} />

## Frequency vs Pitch Perception

Maybe you have already noticed that the <span style="color:#3b82f6;">frequency slider</span> is "lopsided",
meaning the pitch changes more in the left region and less in the right region.<br/>
To make that more obvious, let's add a <span style="color:#eab308">pitch slider</span>
that controls the frequency on a different scale:

<PitchSlider animatable plot showFrequencySlider showPitchSlider client:load />

Try out the buttons above to sweep through the frequency range in 2 different ways:

- Frequency Sweep: <span style="color:#3b82f6;">frequency rises linear</span> , <span style="color:#eab308">pitch rises logarithmic</span>
- Pitch Sweep: <span style="color:#3b82f6;">frequency rises exponential</span> , <span style="color:#eab308">pitch rises linear</span>

<Box>

Don't be scared of these mathematical terms:

- "logarithmic" is just a fancy way of saying "it starts fast and slows down"
- "exponential" is just a fancy way of saying "it starts slow and gets faster"

</Box>

Most of the time, we might want to control pitch in a way that matches our perception,
which is what the <span style="color:#eab308">pitch slider</span> does.

## From Hz to Semitones

Because Hz does not match our perception, let's try to find a unit for pitch that matches.
To approach that unit of pitch, let's look at how frequency behaves when it is doubled:

<PitchSlider client:load showPitchSlider showFrequencySlider pitchStep={1 / 7} />

- Use the now stepped pitch slider above
- Can you hear how these pitches seem related to each other?

<Box>

In musical terms, a pitch with double the frequency of another is an `octave` higher.

</Box>

Because octaves are pretty far apart, octaves are typically divided into 12 smaller parts:

<PitchSlider client:load showPitchSlider showFrequencySlider pitchStep={1 / 12} min={440} max={880} initial={440} />

This step is also called a semitone, which is the most common division of pitched music.
For example, the keys on a piano keyboard are also divided into semitones.

In Strudel, we could do that with `freq` like this:

<MiniRepl
  client:visible
  tune={`freq(
  "0 4 7 12"
  .fmap(n => 440 * 2**(n/12))
)`}
/>

Of course, this can be written shorter with note, as we will see below.

## From Semitones to MIDI numbers

Now we know what the distance of a semitone is.
Above, we used an arbitrary base frequency of 440Hz, which means the exponent 0 is equal to 440Hz.
Typically, 440Hz is standardized to the number 69, which leads to this calculation:

<PitchSlider
  client:load
  showPitchSlider
  showFrequencySlider
  baseFrequency={440}
  zeroOffset={69}
  pitchStep={1 / 12 / 7}
  min={440 / 8}
  max={7040}
  initial={440}
/>

The yellow number is now a MIDI number, covering more than the whole human hearing range with numbers from 0 to 127.
In Strudel, we can use MIDI numbers inside `note`:

<MiniRepl client:visible tune={`note("69 73 76 81")`} />

## From MIDI numbers to notes

In western music theory, notes are used instead of numbers.
For each midi number, there is at least one note label:

<PitchSlider
  client:load
  showPitchSlider
  showFrequencySlider
  baseFrequency={440}
  zeroOffset={69}
  pitchStep={1 / 48}
  min={440 / 8}
  max={880}
  initial={440}
  claviature
/>

A full note label consists of a letter (A-G), 0 or more accidentals (b | #) and an octave number.
This system is also known as [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).
In Strudel, these note labels can also be used inside `note` as an alternative to midi numbers:

<MiniRepl client:visible tune={`note("A4 C#5 E5 A5").piano()`} />

## Open Questions

Now that we have learned about different representations of pitch, there are still open questions:

- Why 12 notes? What about different divisions of the octave?
- Why are notes labeled as they are? Why only 7 letters?
- Are there other labeling systems?
- What about Just Intonation Systems?
- What about Timbre?

All those questions are important to ask and will be answered in another article.

## Definition

At first, I wanted to start this article with a definition, but then thought it might be a good idea to focus on intuitive exploration.
Maybe you now understand this definition much better:

<Box>

From [wikipedia](<https://en.wikipedia.org/wiki/Pitch_(music)>): "Pitch is a perceptual property of sounds that allows their ordering on a frequency-related scale, or more commonly, pitch is the quality that makes it possible to judge sounds as "higher" and "lower" in the sense associated with musical melodies."

</Box>


---
title: Understanding Chord Voicings
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { PitchSlider } from '../../components/PitchSlider';
import Box from '@components/Box.astro';

# Understanding Chords and Voicings

Let's dig deeper into how chords and voicings work in strudel.
I'll try to keep theory jargon to a minimum, so hopefully this is approachable for anyone interested.

## What is a chord

Playing more than one note at a time is generally called a `chord`. Here's an example:

<MiniRepl client:visible tune={`note("<[c3,eb3,g3] [f3,a3,c4]>").room(.5)`} />

Here's the same with midi numbers:

<MiniRepl client:visible tune={`note("<[48,51,55] [53,57,60]>").room(.5)`} />

Here, we have two 3-note chords played in a loop.
You could already stop here and write chords in this style, which is totally fine and gives you control over individual notes.
One downside is that it can be difficult to find good sounding chords and maybe you're yearning for a way to organize chords in some other way.

## Labeling Chords

Chords are typically given different labels depending on the relationship of the notes within.
In the number example above, we have `48,51,55` and `53,57,60`.

To analyze the relationship of those notes, they are typically compared to some `root`, which is often the lowest note.
In our case, the `roots` would be `48` (= `c3`) and `53` (= `f3`).
We can express the same chords relative to those `roots` like this:

<MiniRepl client:visible tune={`note("<[0,3,7] [0,4,7]>".add("<48 53>")).room(.5)`} />

Now within each chord, each number represents the distance from the root.
A distance between pitches is typically called `interval`, but let's stick to distance for now.

Now we can see that our 2 chords are actually quite similar, as the only difference is the middle note (and the root of course).
They are part of a group of chords called `triads` which are chords with 3 notes.

### Triads

These 4 shapes are the most common types of `triads` you will encounter:

| shape | label      |
| ----- | ---------- |
| 0,4,7 | major      |
| 0,3,7 | minor      |
| 0,3,6 | diminished |
| 0,4,8 | augmented  |

Here they are in succession:

<MiniRepl
  client:visible
  tune={`note("<[0,4,7] [0,3,7] [0,3,6] [0,4,8]>".add("60"))
.room(.5)._pitchwheel()`}
/>

Many types of music often only use minor and major chords, so we already have the knowledge to accompany songs. Here's one:

<MiniRepl
  client:visible
  tune={`
note(\`<
[0,3,7] [0,4,7] [0,4,7] [0,4,7]
[0,3,7] [0,4,7] [0,3,7] [0,4,7]
>\`.add(\`<
a c d f
a e a e
>\`)).room(.5)`}
/>

These are the chords for "The House of the Rising Sun" by The Animals.
So far, it doesn't sound too exciting, but at least it's recognizable.

## Voicings

A `voicing` is one of many ways a certain chord shape can be arranged.
The term comes from choral music, where chords can be sung in different ways by assigning different notes to each voice.
For example we could add 12 semitones to one or more notes in the chord:

<MiniRepl
  client:visible
  tune={`note("<[0,3,7] [12,3,7] [12,15,7] [12,15,19]>".add("48"))
.room(.5)`}
/>

Notes that are 12 semitone steps apart (= 1 `octave`) are considered to be equal in a harmonic sense, which is why they get the same note letter.
Here's the same example with note letters:

<MiniRepl
  client:visible
  tune={`note("<[c3,eb3,g3] [c4,eb3,g3] [c4,eb4,g3] [c4,eb4,g4]>")
.room(.5)`}
/>

These types of voicings are also called `inversions`. There are many other ways we could `voice` this minor chord:

<MiniRepl
  client:visible
  tune={`note("<[0,3,7,12] [0,15,24] [0,3,12]>".add("48"))
.room(.5)`}
/>

Here we are changing the flavour of the chord slightly by

1. doubling notes 12 steps higher,
2. using very wide distances
3. omitting notes

## Voice Leading

When we want to meaningfully connect chords in a sequence, the chosen voicings affect the way each chord transitions to the next.
Let's revisit "The House of the Rising Sun", this time using our newly acquired voicing techniques:

<MiniRepl
  client:visible
  tune={`note(\`<
[0,3,7] [7,12,16] [0,7,16] [4,7,12]
[0,3,7] [4,7,12] [0,3,7] [4,7,12]
>\`.add(\`<
a c d f
a e a e
>\`)).room(.5)`}
  punchcard
/>

These voicings make the chords sound more connected and less jumpy, compared to the earlier version, which didn't focus on voicing.
The way chords interact is also called `voice leading`, reminiscent of how an
individual choir voice would move through a sequence of chords.

For example, try singing the top voice in the above example. Then try the same
on the example not focusing on voice leading. Which one's easier?

Naturally, there are many ways a progression of chords could be voiced and there is no definitive right or wrong.

## Chord Symbols

Musicians playing chord-based music often use a `lead sheet`, which is a simplified notation for a piece of music.
These sheets condense the essential elements, such as chords, into symbols that make the music easy to read and follow.
For example, a lead sheet for "The House of the Rising Sun" might include chords written like this:

```
Am | C | D  | F
Am | E | Am | E
```

Here, each symbol consists of the `root` of the chord and optionally an `m` to signal it's a minor chord (just the root note means it's major).
We could mirror that notation in strudel using the `pick` function:

<MiniRepl
  client:visible
  tune={`"<Am C D F Am E Am E>"
  .pick({
    Am: "57,60,64",
    C: "55,60,64",
    D: "50,57,66",
    F: "57,60,65",
    E: "56,59,64",
  })
  .note().room(.5)`}
  punchcard
/>

## The voicing function

Coming up with good sounding voicings that connect well can be a difficult and time consuming process.
The `chord` and `voicing` functions can be used to automate that:

<MiniRepl client:visible tune={`chord("<Am C D F Am E Am E>").voicing().room(.5)`} punchcard />

Here we're also using chord symbols but the voicings will be automatically generated with smooth `voice leading`, minimizing jumps.
It is inspired by the way a piano or guitar player would pick chords to accompany a song.

## Voicing Dictionaries

The voicing function internally uses so called `voicing dictionaries`, which can also be customized:

<MiniRepl
  client:visible
  tune={`addVoicings('house', {
  '': ['7 12 16', '0 7 16', '4 7 12'],
  'm': ['0 3 7']
})
chord("<Am C D F Am E Am E>")
  .dict('house').anchor(66)
  .voicing().room(.5)`}
  punchcard
/>

In a `voicing dictionary`, each chord symbol is assigned one or more voicings.
The `voicing` function then picks the voicing that is closest to the `anchor` (defaults to `c5`).

The handy thing about this approach is that a `voicing dictionary` can be used to play any chord progression with automated voice leading!

## The default dictionary

When using the default dictionary, you can use these chord symbols:

```
2 5 6 7 9 11 13 69 add9
o h sus ^ - ^7 -7 7sus
h7 o7 ^9 ^13 ^7#11 ^9#11
^7#5 -6 -69 -^7 -^9 -9
-add9 -11 -7b5 h9 -b6 -#5
7b9 7#9 7#11 7b5 7#5 9#11
9b5 9#5 7b13 7#9#5 7#9b5
7#9#11 7b9#11 7b9b5 7b9#5
7b9#9 7b9b13 7alt 13#11
13b9 13#9 7b9sus 7susadd3
9sus 13sus 7b13sus
aug M m M7 m7 M9 M13
M7#11 M9#11 M7#5 m6 m69
m^7 -M7 m^9 -M9 m9 madd9
m11 m7b5 mb6 m#5 mM7 mM9
```

The available chords and the format is very much inspired by [ireal pro chords](https://technimo.helpshift.com/hc/en/3-ireal-pro/faq/88-chord-symbols-used-in-ireal-pro/).
Some symbols are synonymous:

- "-" is the same as "m", for example C-7 = Cm7
- "^" is the same as "M", for example C^7 = CM7
- "+" is the same as "aug"

You can decide which ones you prefer. There is no international standard for these symbols.
To get a full chord, the symbols have to be prefixed with a root pitch, e.g. D7#11 is the 7#11 chord relative to the pitch D.

Here are all possible chords with root C:

<MiniRepl
  client:visible
  tune={`chord(\`<
C2 C5 C6 C7 C9 C11 C13 C69
Cadd9 Co Ch Csus C^ C- C^7 
C-7 C7sus Ch7 Co7 C^9 C^13 
C^7#11 C^9#11 C^7#5 C-6 C-69 
C-^7 C-^9 C-9 C-add9 C-11 
C-7b5 Ch9 C-b6 C-#5 C7b9 
C7#9 C7#11 C7b5 C7#5 C9#11 
C9b5 C9#5 C7b13 C7#9#5 C7#9b5 
C7#9#11 C7b9#11 C7b9b5 C7b9#5 
C7b9#9 C7b9b13 C7alt C13#11 
C13b9 C13#9 C7b9sus C7susadd3 
C9sus C13sus C7b13sus C Caug 
CM Cm CM7 Cm7 CM9 CM13 CM7#11 
CM9#11 CM7#5 Cm6 Cm69 Cm^7 
C-M7 Cm^9 C-M9 Cm9 Cmadd9 
Cm11 Cm7b5 Cmb6 Cm#5
>\`).voicing().room(.5)`}
  punchcard
/>

Note that the default dictionary contains multiple ways (= `voicings`) to play each chord symbol.
By default, the `voicing` function tries to minimize jumps.
You can alter the picked voicings in various ways, which are now explained in further detail:

## anchor

The `anchor` is a note that is used to align the voicings to:

<MiniRepl client:visible tune={`anchor("<c4 g4 c5 g5>").chord("C").voicing().room(.5)`} punchcard />

By default, the anchor is the highest possible note the voicing can contain.
When deciding which voicing of the dictionary to pick for a certain chord, the voicing with a top note closest to the anchor wins.

Note that the anchors in the above example match up with the top notes in the pianoroll.
Like `note`, anchor accepts either midi numbers or note names.

## mode

With `mode`, you can change the way the voicing relates to the `anchor`:

<MiniRepl
  client:visible
  tune={`mode("<below above duck root>").chord("C").anchor("c5").voicing().room(.5)`}
  punchcard
/>

The modes are:

- `below`: the top note of the voicing is lower than or equal to the anchor (default)
- `above`: the bottom note of the voicing is higher than or equal to the anchor
- `duck`: the top note of the voicing is lower than the anchor
- `root`: the bottom note of the voicing is always the root note closest to the anchor

The `anchor` can also be set from within the `mode` function:

<MiniRepl client:visible tune={`mode("<below above duck root>:c5").chord("C").voicing().room(.5)`} punchcard />

## n

The `n` control can be used with `voicing` to select individual notes:

<MiniRepl
  client:visible
  tune={`n("0 3 1 2").chord("<C <Fm Db>>").voicing()
.clip("4 3 2 1").room(.5)`}
  punchcard
/>

## Example

Here's an example of a Jazz Blues in F:

<MiniRepl
  client:visible
  tune={`let chords = chord(\`<
F7 Bb7 F7 [Cm7 F7]
Bb7 Bo F7 [Am7 D7]
Gm7 C7 [F7 D7] [Gm7 C7]
>\`)
$: n("7 8 [10 9] 8").set(chords).voicing().dec(.2)
$: chords.struct("- x - x").voicing().room(.5)
$: n("0 - 1 -").set(chords).mode("root:g2").voicing()
`}
  punchcard
/>

The chords are reused for melody, chords and bassline of the tune.


---
title: First Effects
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import QA from '@components/QA';

# First Effects

import Box from '@components/Box.astro';

We have sounds, we have notes, now let's look at effects!

## Some basic effects

**low-pass filter**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("sawtooth").lpf(800)`}
/>

<Box>

lpf = **l**ow **p**ass **f**ilter

- Change lpf to 200. Notice how it gets muffled. Think of it as standing in front of the club with the door closed üö™.
- Now let's open the door... change it to 5000. Notice how it gets brighter ‚ú®ü™©

</Box>

**pattern the filter**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("sawtooth").lpf("200 1000 200 1000")`}
/>

<Box>

- Try adding more values
- Notice how the pattern in lpf does not change the overall rhythm

We will learn how to automate with waves later...

</Box>

**vowel**

<MiniRepl
  client:visible
  tune={`note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>")
.sound("sawtooth").vowel("<a e i o>")`}
/>

**gain**

<MiniRepl
  client:visible
  tune={`$: sound("hh*16").gain("[.25 1]*4")

$: sound("bd*4,[~ sd:1]*2")`}
punchcard
/>

<Box>

Rhythm is all about dynamics!

- Remove `.gain(...)` and notice how flat it sounds.
- Bring it back by undoing (ctrl+z)

</Box>

Let's combine all of the above into a little tune:

<MiniRepl
  client:visible
  tune={`$: sound("hh*8").gain("[.25 1]*4")

$: sound("bd*4,[~ sd:1]*2")

$: note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("sawtooth").lpf("200 1000 200 1000")

$: note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>")
.sound("sawtooth").vowel("<a e i o>")`}
/>

**shape the sound with an adsr envelope**

<MiniRepl
  client:visible
  tune={`note("c3 bb2 f3 eb3")
.sound("sawtooth").lpf(600)
.attack(.1)
.decay(.1)
.sustain(.25)
.release(.2)`}
/>

<Box>

Try to find out what the numbers do.. Compare the following

- attack: `.5` vs `0`
- decay: `.5` vs `0`
- sustain: `1` vs `.25` vs `0`
- release: `0` vs `.5` vs `1`

Can you guess what they do?

</Box>

<QA q="Click to see solution" client:visible>

- attack: time it takes to fade in
- decay: time it takes to fade to sustain
- sustain: level after decay
- release: time it takes to fade out after note is finished

![ADSR](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/ADSR_parameter.svg/1920px-ADSR_parameter.svg.png)

</QA>

**adsr short notation**

<MiniRepl
  client:visible
  tune={`note("c3 bb2 f3 eb3")
.sound("sawtooth").lpf(600)
.adsr(".1:.1:.5:.2")
`}
/>

**delay**

<MiniRepl
  client:visible
  tune={`$: note("[~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]]*2")
  .sound("gm_electric_guitar_muted").delay(.5)

$: sound("bd rim").bank("RolandTR707").delay(".5")`}
/>

<Box>

Try some `delay` values between 0 and 1. Btw, `.5` is short for `0.5`

What happens if you use `.delay(".8:.125")` ? Can you guess what the second number does?

What happens if you use `.delay(".8:.06:.8")` ? Can you guess what the third number does?

</Box>

<QA q="Click to see solution" client:visible>

`delay("a:b:c")`:

- a: delay volume
- b: delay time
- c: feedback (smaller number = quicker fade)

</QA>

**room aka reverb**

<MiniRepl
  client:visible
  tune={`n("<4 [3@3 4] [<2 0> ~@16] ~>")
.scale("D4:minor").sound("gm_accordion:2")
.room(2)`}
/>

<Box>

Try different values!

Add a delay too!

</Box>

**little dub tune**

<MiniRepl
  client:visible
  tune={`$: note("[~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]]*2")
.sound("gm_electric_guitar_muted").delay(.5)

$: sound("bd rim").bank("RolandTR707").delay(.5)

$: n("<4 [3@3 4] [<2 0> ~@16] ~>")
.scale("D4:minor").sound("gm_accordion:2")
.room(2).gain(.5)`}
/>

Let's add a bass to make this complete:

<MiniRepl
  client:visible
  tune={`$: note("[~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]]*2")
.sound("gm_electric_guitar_muted").delay(.5)

$: sound("bd rim").bank("RolandTR707").delay(.5)

$: n("<4 [3@3 4] [<2 0> ~@16] ~>")
.scale("D4:minor").sound("gm_accordion:2")
.room(2).gain(.4)

$: n("[0 [~ 0] 4 [3 2] [0 ~] [0 ~] <0 2> ~]/2")
.scale("D2:minor")
.sound("sawtooth,triangle").lpf(800)`}
/>

<Box>

Try adding `.hush()` at the end of one of the patterns in the stack...

</Box>

**pan**

<MiniRepl
  client:visible
  tune={`sound("numbers:1 numbers:2 numbers:3 numbers:4")
  .pan("0 0.3 .6 1")`}
/>

**speed**

<MiniRepl client:visible tune={`sound("bd rim [~ bd] rim").speed("<1 2 -1 -2>").room(.2)`} />

**fast and slow**

We can use `fast` and `slow` to change the tempo of a pattern outside of Mini-Notation:

<MiniRepl client:visible tune={`sound("bd*4,~ rim ~ cp").slow(2)`} />

<Box>

Change the `slow` value. Try replacing it with `fast`.

What happens if you use a pattern like `.fast("<1 [2 4]>")`?

</Box>

By the way, inside Mini-Notation, `fast` is `*` and `slow` is `/`.

<MiniRepl client:visible tune={`sound("[bd*4,~ rim ~ cp]*<1 [2 4]>")`} />

## modulation with signals

Instead of changing values stepwise, we can also control them with signals:

<MiniRepl client:visible tune={`sound("hh*16").gain(sine)`} punchcard punchcardLabels={false} />

<Box>

The basic waveforms for signals are `sine`, `saw`, `square`, `tri` üåä

Try also random signals `rand` and `perlin`!

The gain is visualized as transparency in the pianoroll.

</Box>

**setting a range**

By default, waves oscillate between 0 to 1. We can change that with `range`:

<MiniRepl client:visible tune={`sound("hh*16").lpf(saw.range(500, 2000))`} />

<Box>

What happens if you flip the range values?

</Box>

We can change the modulation speed with slow / fast:

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
  .sound("sawtooth")
  .lpf(sine.range(100, 2000).slow(4))`}
/>

<Box>

The whole modulation will now take 8 cycles to repeat.

</Box>

## Recap

| name    | example                                                                                                          |
| ------- | ---------------------------------------------------------------------------------------------------------------- |
| lpf     | <MiniRepl client:visible tune={`note("c2 c3 c2 c3").s("sawtooth").lpf("<400 2000>")`} />                         |
| vowel   | <MiniRepl client:visible tune={`note("c3 eb3 g3").s("sawtooth").vowel("<a e i o>")`} />                          |
| gain    | <MiniRepl client:visible tune={`s("hh*16").gain("[.25 1]*2")`} />                                                |
| delay   | <MiniRepl client:visible tune={`s("bd rim bd cp").delay(.5)`} />                                                 |
| room    | <MiniRepl client:visible tune={`s("bd rim bd cp").room(.5)`} />                                                  |
| pan     | <MiniRepl client:visible tune={`s("bd rim bd cp").pan("0 1")`} />                                                |
| speed   | <MiniRepl client:visible tune={`s("bd rim bd cp").speed("<1 2 -1 -2>")`} />                                      |
| signals | `sine`, `saw`, `square`, `tri`, `rand`, `perlin`<br/><MiniRepl client:visible tune={`s("hh*16").gain  (saw)`} /> |
| range   | <MiniRepl client:visible tune={`s("hh*16").lpf(saw.range(200,4000))`} />                                         |

Let us now take a look at some of Tidal's typical [pattern effects](/workshop/pattern-effects).


---
title: First Notes
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '@src/docs/MiniRepl';
import { midi2note } from '@strudel/core';
import Box from '@components/Box.astro';
import QA from '@components/QA';

# First Notes

Let's look at how we can play notes

## numbers and notes

**play notes with numbers**

<MiniRepl
  client:visible
  tune={`note("48 52 55 59").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    Array(49)
      .fill()
      .map((_, i) => [midi2note(i + 36), i + 36]),
  )}
/>

<Box>

Try out different numbers!

Try decimal numbers, like 55.5

</Box>

**play notes with letters**

<MiniRepl
  client:visible
  tune={`note("c e g b").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(['c3', 'd3', 'e3', 'f3', 'g3', 'a3', 'b3'].map((n) => [n, n.split('')[0]]))}
/>

<Box>

Try out different letters (a - g).

Can you find melodies that are actual words? Hint: ‚òï üòâ ‚ö™

</Box>

**add flats or sharps to play the black keys**

<MiniRepl
  client:visible
  tune={`note("db eb gb ab bb").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    ['db3', 'eb3', 'gb3', 'ab3', 'bb3'].map((n) => [n, n.split('').slice(0, 2).join('')]),
  )}
/>

<MiniRepl
  client:visible
  tune={`note("c# d# f# g# a#").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    ['c#3', 'd#3', 'f#3', 'g#3', 'a#3'].map((n) => [n, n.split('').slice(0, 2).join('')]),
  )}
/>

**play notes with letters in different octaves**

<MiniRepl
  client:visible
  tune={`note("c2 e3 g4 b5").sound("piano")`}
  claviature
  claviatureLabels={Object.fromEntries(
    Array(49)
      .fill()
      .map((_, i) => [midi2note(i + 36), midi2note(i + 36)]),
  )}
/>

<Box>

Try out different octaves (1-8)

</Box>

If you are not comfortable with the note letter system, it should be easier to use numbers instead.
Most of the examples below will use numbers for that reason.
We will also look at ways to make it easier to play the right notes later.

## changing the sound

Just like with unpitched sounds, we can change the sound of our notes with `sound`:

<MiniRepl client:visible tune={`note("36 43, 52 59 62 64").sound("piano")`} />

{/* c2 g2, e3 b3 d4 e4 */}

<Box>

Try out different sounds:

- gm_electric_guitar_muted
- gm_acoustic_bass
- gm_voice_oohs
- gm_blown_bottle
- sawtooth
- square
- triangle
- how about bd, sd or hh?
- remove `.sound('...')` completely

</Box>

**switch between sounds**

<MiniRepl
  client:visible
  tune={`note("48 67 63 [62, 58]")
.sound("piano gm_electric_guitar_muted")`}
/>

**stack multiple sounds**

<MiniRepl
  client:visible
  tune={`note("48 67 63 [62, 58]")
.sound("piano, gm_electric_guitar_muted")`}
/>

<Box>

The `note` and `sound` patterns are combined!

We will see more ways to combine patterns later..

</Box>

## Longer Sequences

**Divide sequences with `/` to slow them down**

<MiniRepl client:visible tune={`note("[36 34 41 39]/4").sound("gm_acoustic_bass")`} punchcard />

<Box>

The `/4` plays the sequence in brackets over 4 cycles (=8s).

So each of the 4 notes is 2s long.

Try adding more notes inside the brackets and notice how it gets faster.

</Box>

**Play one per cycle with `< ... >`**

In the last section, we learned that `< ... >` (angle brackets) can be used to play only one thing per cycle,
which is useful for longer melodies too:

<MiniRepl client:visible tune={`note("<36 34 41 39>").sound("gm_acoustic_bass")`} punchcard />

<Box>

Try adding more notes inside the brackets and notice how the tempo stays the same.

The angle brackets are actually just a shortcut:

`<a b c>` = `[a b c]/3`

`<a b c d>` = `[a b c d]/4`

...

</Box>

**Play one sequence per cycle**

We can combine the 2 types of brackets in all sorts of different ways.
Here is an example of a repetitive bassline:

<MiniRepl
  client:visible
  tune={`note("<[36 48]*4 [34 46]*4 [41 53]*4 [39 51]*4>")
.sound("gm_acoustic_bass")`}
  punchcard
/>

**Alternate between multiple things**

<MiniRepl
  client:visible
  tune={`note("60 <63 62 65 63>")
.sound("gm_xylophone")`}
  punchcard
/>

This is also useful for unpitched sounds:

<MiniRepl
  client:visible
  tune={`sound("bd*4, [~ <sd cp>]*2, [~ hh]*4")
.bank("RolandTR909")`}
  punchcard
/>

## Scales

Finding the right notes can be difficult.. Scales are here to help:

<MiniRepl
  client:visible
  tune={`setcpm(60)
n("0 2 4 <[6,8] [7,9]>")
.scale("C:minor").sound("piano")`}
  punchcard
/>

<Box>

Try out different numbers. Any number should sound good!

Try out different scales:

- C:major
- A2:minor
- D:dorian
- G:mixolydian
- A2:minor:pentatonic
- F:major:pentatonic

</Box>

**automate scales**

Just like anything, we can automate the scale with a pattern:

<MiniRepl
  client:visible
  tune={`setcpm(60)
n("<0 -3>, 2 4 <[6,8] [7,9]>")
.scale("<C:major D:mixolydian>/4")
.sound("piano")`}
  punchcard
/>

<Box>

If you have no idea what these scale mean, don't worry.
These are just labels for different sets of notes that go well together.

Take your time and you'll find scales you like!

</Box>

## Repeat & Elongate

**Elongate with @**

<MiniRepl client:visible tune={`note("c@3 eb").sound("gm_acoustic_bass")`} punchcard />

<Box>

Not using `@` is like using `@1`. In the above example, c is 3 units long and eb is 1 unit long.

Try changing that number!

</Box>

**Elongate within sub-sequences**

<MiniRepl
  client:visible
  tune={`setcpm(60)
n("<[4@2 4] [5@2 5] [6@2 6] [5@2 5]>*2")
.scale("<C2:mixolydian F2:mixolydian>/4")
.sound("gm_acoustic_bass")`}
  punchcard
/>

<Box>

This groove is called a `shuffle`.
Each beat has two notes, where the first is twice as long as the second.
This is also sometimes called triplet swing. You'll often find it in blues and jazz.

</Box>

**Replicate**

<MiniRepl
  client:visible
  tune={`setcpm(60)
note("c!2 [eb,<g a bb a>]").sound("piano")`}
  punchcard
/>

<Box>

Try switching between `!`, `*` and `@`

What's the difference?

</Box>

## Recap

Let's recap what we've learned in this chapter:

| Concept   | Syntax | Example                                                  |
| --------- | ------ | -------------------------------------------------------- |
| Slow down | \/     | <MiniRepl client:visible tune={`note("[c a f e]/2")`} /> |
| Alternate | \<\>   | <MiniRepl client:visible tune={`note("c a f <e g>")`} /> |
| Elongate  | @      | <MiniRepl client:visible tune={`note("c@3 e")`} />       |
| Replicate | !      | <MiniRepl client:visible tune={`note("c!3 e")`} />       |

New functions:

| Name  | Description                   | Example                                                                           |
| ----- | ----------------------------- | --------------------------------------------------------------------------------- |
| note  | set pitch as number or letter | <MiniRepl client:visible tune={`note("b g e c").sound("piano")`} />               |
| scale | interpret `n` as scale degree | <MiniRepl client:visible tune={`n("6 4 2 0").scale("C:minor").sound("piano")`} /> |
| $:    | play patterns in parallel     | <MiniRepl client:visible tune={'$: s("bd sd")\n$: note("c eb g")'} />             |

## Examples

**Classy Bassline**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
.sound("gm_synth_bass_1")
.lpf(800) // <-- we'll learn about this soon`}
/>

**Classy Melody**

<MiniRepl
  client:visible
  tune={`n(\`<
[~ 0] 2 [0 2] [~ 2]
[~ 0] 1 [0 1] [~ 1]
[~ 0] 3 [0 3] [~ 3]
[~ 0] 2 [0 2] [~ 2]
>*4\`).scale("C4:minor")
.sound("gm_synth_strings_1")`}
/>

**Classy Drums**

<MiniRepl
  client:visible
  tune={`sound("bd*4, [~ <sd cp>]*2, [~ hh]*4")
.bank("RolandTR909")`}
/>

**If there just was a way to play all the above at the same time.......**

<Box>

You can use `$:` üòô

</Box>

## Playing multiple patterns

If you want to play multiple patterns at the same time, make sure to write `$:` before each:

<MiniRepl
  client:visible
  tune={`$: note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>")
  .sound("gm_synth_bass_1").lpf(800)
  
$: n(\`<
  [~ 0] 2 [0 2] [~ 2]
  [~ 0] 1 [0 1] [~ 1]
  [~ 0] 3 [0 3] [~ 3]
  [~ 0] 2 [0 2] [~ 2]
  >*4\`).scale("C4:minor")
  .sound("gm_synth_strings_1")
  
$: sound("bd*4, [~ <sd cp>]*2, [~ hh]*4")
.bank("RolandTR909")`}
/>

<Box>

Try changing `$` to `_$` to mute a part!

</Box>

This is starting to sound like actual music! We have sounds, we have notes, now the last piece of the puzzle is missing: [effects](/workshop/first-effects)


---
title: First Sounds
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '@src/docs/MiniRepl';
import Box from '@components/Box.astro';
import QA from '@components/QA';

# First Sounds

This is the first chapter of the Strudel Workshop, nice to have you on board!

## Code Fields

The workshop is full of interactive code fields. Let's learn how to use those. Here is one:

<MiniRepl client:visible tune={`sound("casio")`} dirt />

<Box>

1. ‚¨ÜÔ∏è click into the text field above ‚¨ÜÔ∏è
2. press `ctrl`+`enter` to play
3. change `casio` to `metal`
4. press `ctrl`+`enter` to update
5. press `ctrl`+`.` to stop

</Box>

Congratulations, you are now live coding!

## Sounds

We have just played a sound with `sound` like this:

<MiniRepl client:visible tune={`sound("casio")`} />

<Box>

`casio` is one of many standard sounds.

Try out a few other sounds:

```
insect wind jazz metal east crow casio space numbers
```

You might hear a little pause while the sound is loading

</Box>

**Change Sample Number with :**

One Sound can contain multiple samples (audio files).

You can select the sample by appending `:` followed by a number to the name:

<MiniRepl client:visible tune={`sound("casio:1")`} />

<Box>

Try different sound / sample number combinations.

Not adding a number is like doing `:0`

</Box>

Now you know how to use different sounds.
For now we'll stick to this little selection of sounds, but we'll find out how to load your own sounds later.

## Drum Sounds

By default, Strudel comes with a wide selection of drum sounds:

<MiniRepl client:visible tune={`sound("bd hh sd oh")`} />

<Box>

These letter combinations stand for different parts of a drum set:

<img src="/img/drumset.png" />

<a class="text-right text-xs" href="https://de.wikipedia.org/wiki/Schlagzeug#/media/Datei:Drum_set.svg" target="_blank">
  original image by Pbroks13
</a>

- `bd` = **b**ass **d**rum
- `sd` = **s**nare **d**rum
- `rim` = **rim**shot
- `hh` = **h**i**h**at
- `oh` = **o**pen **h**ihat
- `lt` = **l**ow tom
- `mt` = **m**iddle tom
- `ht` = **h**igh tom
- `rd` = **r**i**d**e cymbal
- `cr` = **cr**ash cymbal

Try out different drum sounds!

</Box>

To change the sound character of our drums, we can use `bank` to change the drum machine:

<MiniRepl client:visible tune={`sound("bd hh sd oh").bank("RolandTR909")`} />

In this example `RolandTR909` is the name of the drum machine that we're using.
It is a famous drum machine for house and techno beats.

<Box>

Try changing `RolandTR909` to one of

- `AkaiLinn`
- `RhythmAce`
- `RolandTR808`
- `RolandTR707`
- `ViscoSpaceDrum`

There are a lot more, but let's keep it simple for now

ü¶• Pro-Tip: Mark a name via double click. Then just copy and paste!

</Box>

## Sequences

In the last example, we already saw that you can play multiple sounds in a sequence by separating them with a space:

<MiniRepl client:visible tune={`sound("bd hh sd hh")`} punchcard />

Notice how the currently playing sound is highlighted in the code and also visualized below.

<Box>

Try adding more sounds to the sequence!

</Box>

**The longer the sequence, the faster it runs**

<MiniRepl client:visible tune={`sound("bd bd hh bd rim bd hh bd")`} punchcard />

The content of a sequence will be squished into what's called a cycle. A cycle is 2s long by default.

**One per cycle with `< .. >`**

Here is the same sequence, but this time sourrounded with `< .. >` (angle brackets):

<MiniRepl client:visible tune={`sound("<bd bd hh bd rim bd hh bd>")`} punchcard />

This will play only one sound per cycle. With these brackets, the tempo doesn't change when we add or remove elements!

Because this is now very slow, we can speed it up again like this:

<MiniRepl client:visible tune={`sound("<bd bd hh bd rim bd hh bd>*8")`} punchcard />

Here, the `*8` means we make the whole thing 8 times faster.

<Box>

Wait a minute, isn't this the same as without `< ... >*8`? Why do we need it then?

That's true, the special thing about this notation is that the tempo won't change when you add or remove elements, try it!

Try also changing the number at the end to change the tempo!

</Box>

**changing the tempo with setcpm**

<MiniRepl
  client:visible
  tune={`setcpm(90/4)
sound("<bd hh rim hh>*8")`}
  punchcard
/>

<Box>

cpm = cycles per minute

By default, the tempo is 30 cycles per minute = 120/4 = 1 cycle every 2 seconds

In western music terms, you could say the above are 8ths notes at 90bpm in 4/4 time.
But don't worry if you don't know these terms, as they are not required to make music with Strudel.

</Box>

**Add a rests in a sequence with '-' or '~'**

<MiniRepl client:visible tune={`sound("bd hh - rim - bd hh rim")`} punchcard />

**Sub-Sequences with [brackets]**

<MiniRepl client:visible tune={`sound("bd [hh hh] sd [hh bd] bd - [hh sd] cp")`} punchcard />

<Box>

Try adding more sounds inside a bracket!

</Box>

Similar to the whole sequence, the content of a sub-sequence will be squished to its own length.

**Multiplication: Speed things up**

<MiniRepl client:visible tune={`sound("bd hh*2 rim hh*3 bd [- hh*2] rim hh*2")`} punchcard />

**Multiplication: Speed up subsequences**

<MiniRepl client:visible tune={`sound("bd [hh rim]*2 bd [hh rim]*1.5")`} punchcard />

**Multiplication: Speeeeeeeeed things up**

<MiniRepl client:visible tune={`sound("bd hh*32 rim hh*16")`} punchcard />

<Box>

Pitch = really fast rhythm

</Box>

**Sub-Sub-Sequences with [[brackets]]**

<MiniRepl client:visible tune={`sound("bd [[rim rim] hh] bd cp")`} punchcard />

<Box>

You can go as deep as you want!

</Box>

**Play sequences in parallel with comma**

<MiniRepl client:visible tune={`sound("hh hh hh, bd casio")`} punchcard />

You can use as many commas as you want:

<MiniRepl client:visible tune={`sound("hh hh hh, bd bd, - casio")`} punchcard />

Commas can also be used inside sub-sequences:

<MiniRepl client:visible tune={`sound("hh hh hh, bd [bd,casio]")`} punchcard />

<Box>

Notice how the 2 above are the same?

It is quite common that there are many ways to express the same idea.

</Box>

**Multiple Lines with backticks**

<MiniRepl
  client:visible
  tune={`sound(\`bd*2, - cp, 
- - - oh, hh*4,
[- casio]*2\`)`}
  punchcard
/>

**selecting sample numbers separately**

Instead of selecting sample numbers one by one:

<MiniRepl client:visible tune={`sound("jazz:0 jazz:1 [jazz:4 jazz:2] jazz:3*2")`} punchcard />

We can also use the `n` function to make it shorter and more readable:

<MiniRepl client:visible tune={`n("0 1 [4 2] 3*2").sound("jazz")`} punchcard />

## Recap

Now we've learned the basics of the so called Mini-Notation, the rhythm language of Tidal.
This is what we've learned so far:

| Concept           | Syntax   | Example                                                                 |
| ----------------- | -------- | ----------------------------------------------------------------------- |
| Sequence          | space    | <MiniRepl client:visible tune={`sound("bd bd sd hh")`} />               |
| Sample Number     | :x       | <MiniRepl client:visible tune={`sound("hh:0 hh:1 hh:2 hh:3")`} />       |
| Rests             | - or ~   | <MiniRepl client:visible tune={`sound("metal - jazz jazz:1")`} />       |
| Alternate         | \<\>     | <MiniRepl client:visible tune={`sound("<bd hh rim oh bd rim>")`} />     |
| Sub-Sequences     | \[\]     | <MiniRepl client:visible tune={`sound("bd wind [metal jazz] hh")`} />   |
| Sub-Sub-Sequences | \[\[\]\] | <MiniRepl client:visible tune={`sound("bd [metal [jazz [sd cp]]]")`} /> |
| Speed up          | \*       | <MiniRepl client:visible tune={`sound("bd sd*2 cp*3")`} />              |
| Parallel          | ,        | <MiniRepl client:visible tune={`sound("bd*2, hh*2 [hh oh]")`} />        |

The Mini-Notation is usually used inside some function. These are the functions we've seen so far:

| Name   | Description                         | Example                                                                           |
| ------ | ----------------------------------- | --------------------------------------------------------------------------------- |
| sound  | plays the sound of the given name   | <MiniRepl client:visible tune={`sound("bd sd [- bd] sd")`} />                     |
| bank   | selects the sound bank              | <MiniRepl client:visible tune={`sound("bd sd [- bd] sd").bank("RolandTR909")`} /> |
| setcpm | sets the tempo in cycles per minute | <MiniRepl client:visible tune={`setcpm(45); sound("bd sd [- bd] sd")`} />         |
| n      | select sample number                | <MiniRepl client:visible tune={`n("0 1 4 2 0 6 3 2").sound("jazz")`} />           |

## Examples

**Basic rock beat**

<MiniRepl
  client:visible
  tune={`setcpm(100/4)
sound("[bd sd]*2, hh*8").bank("RolandTR505")`}
  punchcard
/>

**Classic house**

<MiniRepl client:visible tune={`sound("bd*4, [- cp]*2, [- hh]*4").bank("RolandTR909")`} punchcard />

<Box>

Notice that the two patterns are extremely similar.
Certain drum patterns are reused across genres.

</Box>

We Will Rock you

<MiniRepl
  client:visible
  tune={`setcpm(81/2)
sound("bd*2 cp").bank("RolandTR707")`}
  punchcard
/>

**Yellow Magic Orchestra - Firecracker**

<MiniRepl
  client:visible
  tune={`setcpm(120/2)
sound("bd sd, - - - hh - hh - -, - perc - perc:1*2")
.bank("RolandCompurhythm1000")`}
  punchcard
/>

**Imitation of a 16 step sequencer**

<MiniRepl
  client:visible
  tune={`
setcpm(90/4)
sound(\`
[-  -  oh - ] [-  -  -  - ] [-  -  -  - ] [-  -  -  - ],
[hh hh -  - ] [hh -  hh - ] [hh -  hh - ] [hh -  hh - ],
[-  -  -  - ] [cp -  -  - ] [-  -  -  - ] [cp -  -  - ],
[bd -  -  - ] [-  -  -  bd] [-  -  bd - ] [-  -  -  bd]
\`)`}
  punchcard
/>

**Another one**

<MiniRepl
  client:visible
  tune={`setcpm(88/4)
sound(\`
[-  -  -  - ] [-  -  -  - ] [-  -  -  - ] [-  -  oh:1 - ],
[hh hh hh hh] [hh hh hh hh] [hh hh hh hh] [hh hh -  - ],
[-  -  -  - ] [cp -  -  - ] [-  -  -  - ] [~  cp -  - ],
[bd bd -  - ] [-  -  bd - ] [bd bd - bd ] [-  -  -  - ]
\`).bank("RolandTR808")`}
  punchcard
/>

**Not your average drums**

<MiniRepl
  client:visible
  tune={`setcpm(100/2)
s(\`jazz*2, 
insect [crow metal] - -, 
- space:4 - space:1,
- wind\`)`}
  punchcard
/>

Now that we know the basics of how to make beats, let's look at how we can play [notes](/workshop/first-notes).


---
title: Getting Started
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { examples } from '../../examples.mjs';

# Welcome

<div className="w-32 animate-pulse md:float-right ml-8">![Strudel Icon](/icons/strudel_icon.png)</div>

Welcome to the Strudel documentation pages!
You've come to the right place if you want to learn how to make music with code.

## What is Strudel?

With Strudel, you can expressively write dynamic music pieces.<br/>
It is an official port of the [Tidal Cycles](https://tidalcycles.org/) pattern language to JavaScript.<br/>
You don't need to know JavaScript or Tidal Cycles to make music with Strudel.
This interactive tutorial will guide you through the basics of Strudel.<br/>
The best place to actually make music with Strudel is the [Strudel REPL](https://strudel.cc/)

<div className="clear-both" />

## What can you do with Strudel?

- live code music: make music with code in real time
- algorithmic composition: compose music using tidal's unique approach to pattern manipulation
- teaching: focussing on a low barrier of entry, Strudel is a good fit for teaching music and code at the same time.
- integrate into your existing music setup: either via MIDI or OSC, you can use Strudel as a really flexible sequencer

## Examples

Here are some examples of how strudel can sound:

<MiniRepl client:idle tunes={examples} />

These examples cannot fully encompass the variety of things you can do, so [check out the showcase](/intro/showcase/) for some videos of how people use Strudel.

## Getting Started

The best way to start learning Strudel is the workshop.
If you're ready to dive in, let's start with your [first sounds](/workshop/first-sounds)


---
title: Pattern Effects
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '@src/docs/MiniRepl';
import Box from '@components/Box.astro';
import QA from '@components/QA';

# Pattern Effects

Up until now, most of the functions we've seen are what other music programs are typically capable of: sequencing sounds, playing notes, controlling effects.

In this chapter, we are going to look at functions that are more unique to tidal.

**reverse patterns with rev**

<MiniRepl client:visible tune={`n("0 1 [4 3] 2 0 2 [~ 3] 4").sound("jazz").rev()`} />

**play pattern left and modify it right with jux**

<MiniRepl client:visible tune={`n("0 1 [4 3] 2 0 2 [~ 3] 4").sound("jazz").jux(rev)`} />

This is the same as:

<MiniRepl
  client:visible
  tune={`$: n("0 1 [4 3] 2 0 2 [~ 3] 4").sound("jazz").pan(0)
$: n("0 1 [4 3] 2 0 2 [~ 3] 4").sound("jazz").pan(1).rev()`}
/>

Let's visualize what happens here:

<MiniRepl
  client:visible
  tune={`$: n("0 1 [4 3] 2 0 2 [~ 3] 4").sound("jazz").pan(0).color("cyan")
$: n("0 1 [4 3] 2 0 2 [~ 3] 4").sound("jazz").pan(1).color("magenta").rev()`}
  punchcard
/>

<Box>

Try commenting out one of the two by adding `//` before a line

</Box>

**multiple tempos**

<MiniRepl client:visible tune={`note("c2, eb3 g3 [bb3 c4]").sound("piano").slow("0.5,1,1.5")`} />

This is like doing

<MiniRepl
  client:visible
  tune={`$: note("c2, eb3 g3 [bb3 c4]").s("piano").slow(0.5).color('cyan')
$: note("c2, eb3 g3 [bb3 c4]").s("piano").slow(1).color('magenta')
$: note("c2, eb3 g3 [bb3 c4]").s("piano").slow(1.5).color('yellow')`}
  punchcard
/>

<Box>

Try commenting out one or more by adding `//` before a line

</Box>

**add**

<MiniRepl
  client:visible
  tune={`setcpm(60)
note("c2 [eb3,g3] ".add("<0 <1 -1>>"))
.color("<cyan <magenta yellow>>").adsr("[.1 0]:.2:[1 0]")
.sound("gm_acoustic_bass").room(.5)`}
  punchcard
/>

<Box>

If you add a number to a note, the note will be treated as if it was a number

</Box>

We can add as often as we like:

<MiniRepl
  client:visible
  tune={`setcpm(60)
note("c2 [eb3,g3]".add("<0 <1 -1>>").add("0,7"))
.color("<cyan <magenta yellow>>").adsr("[.1 0]:.2:[1 0]")
.sound("gm_acoustic_bass").room(.5)`}
  punchcard
/>

**add with scale**

<MiniRepl
  client:visible
  tune={`n("0 [2 4] <3 5> [~ <4 1>]".add("<0 [0,2,4]>"))
.scale("C5:minor").release(.5)
.sound("gm_xylophone").room(.5)`}
  punchcard
/>

**time to stack**

<MiniRepl
  client:visible
  tune={`$: n("0 [2 4] <3 5> [~ <4 1>]".add("<0 [0,2,4]>"))
  .scale("C5:minor")
  .sound("gm_xylophone")
  .room(.4).delay(.125)
$: note("c2 [eb3,g3]".add("<0 <1 -1>>"))
  .adsr("[.1 0]:.2:[1 0]")
  .sound("gm_acoustic_bass")
  .room(.5)
$: n("0 1 [2 3] 2").sound("jazz").jux(rev)`}
/>

**ply**

<MiniRepl client:visible tune={`sound("hh hh, bd rim [~ cp] rim").bank("RolandTR707").ply(2)`} punchcard />

this is like writing:

<MiniRepl client:visible tune={`sound("hh*2 hh*2, bd*2 rim*2 [~ cp*2] rim*2").bank("RolandTR707")`} punchcard />

<Box>

Try patterning the `ply` function, for example using `"<1 2 1 3>"`

</Box>

**off**

<MiniRepl
  client:visible
  tune={`n("0 [4 <3 2>] <2 3> [~ 1]"
  .off(1/16, x=>x.add(4))
  //.off(1/8, x=>x.add(7))
).scale("<C5:minor Db5:mixolydian>/2")
.s("triangle").room(.5).dec(.1)`}
  punchcard
/>

<Box>

In the notation `.off(1/16, x=>x.add(4))`, says:

- take the original pattern named as `x`
- modify `x` with `.add(4)`, and
- play it offset to the original pattern by `1/16` of a cycle.

</Box>

off is also useful for modifying other sounds, and can even be nested:

<MiniRepl
  client:visible
  tune={`s("bd sd [rim bd] sd,[~ hh]*4").bank("CasioRZ1")
  .off(2/16, x=>x.speed(1.5).gain(.25)
  .off(3/16, y=>y.vowel("<a e i o>*8")))`}
/>

| name | description                    | example                                                                                     |
| ---- | ------------------------------ | ------------------------------------------------------------------------------------------- |
| rev  | reverse                        | <MiniRepl client:visible tune={`n("0 2 4 6 ~ 7 9 5").scale("C:minor").rev()`} />            |
| jux  | split left/right, modify right | <MiniRepl client:visible tune={`n("0 2 4 6 ~ 7 9 5").scale("C:minor").jux(rev)`} />         |
| add  | add numbers / notes            | <MiniRepl client:visible tune={`n("0 2 4 6 ~ 7 9 5".add("<0 1 2 1>")).scale("C:minor")`} /> |
| ply  | speed up each event n times    | <MiniRepl client:visible tune={`s("bd sd [~ bd] sd").ply("<1 2 3>")`} />                    |
| off  | copy, shift time & modify      | <MiniRepl client:visible tune={`s("bd sd [~ bd] sd, hh*8").off(1/16, x=>x.speed(2))`} />    |


---
title: Recap
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';

# Workshop Recap

This page is just a listing of all functions covered in the workshop!

## Mini Notation

| Concept           | Syntax   | Example                                                               |
| ----------------- | -------- | --------------------------------------------------------------------- |
| Sequence          | space    | <MiniRepl client:visible tune={`sound("bd bd sd hh bd cp sd hh")`} /> |
| Sample Number     | :x       | <MiniRepl client:visible tune={`sound("hh:0 hh:1 hh:2 hh:3")`} />     |
| Rests             | ~        | <MiniRepl client:visible tune={`sound("metal ~ jazz jazz:1")`} />     |
| Sub-Sequences     | \[\]     | <MiniRepl client:visible tune={`sound("bd wind [metal jazz] hh")`} /> |
| Sub-Sub-Sequences | \[\[\]\] | <MiniRepl client:visible tune={`sound("bd [metal [jazz sd]]")`} />    |
| Speed up          | \*       | <MiniRepl client:visible tune={`sound("bd sd*2 cp*3")`} />            |
| Parallel          | ,        | <MiniRepl client:visible tune={`sound("bd*2, hh*2 [hh oh]")`} />      |
| Slow down         | \/       | <MiniRepl client:visible tune={`note("[c a f e]/2")`} />              |
| Alternate         | \<\>     | <MiniRepl client:visible tune={`note("c <e g>")`} />                  |
| Elongate          | @        | <MiniRepl client:visible tune={`note("c@3 e")`} />                    |
| Replicate         | !        | <MiniRepl client:visible tune={`note("c!3 e")`} />                    |

## Sounds

| Name  | Description                       | Example                                                                 |
| ----- | --------------------------------- | ----------------------------------------------------------------------- |
| sound | plays the sound of the given name | <MiniRepl client:visible tune={`sound("bd sd")`} />                     |
| bank  | selects the sound bank            | <MiniRepl client:visible tune={`sound("bd sd").bank("RolandTR909")`} /> |
| n     | select sample number              | <MiniRepl client:visible tune={`n("0 1 4 2").sound("jazz")`} />         |

## Notes

| Name      | Description                   | Example                                                                           |
| --------- | ----------------------------- | --------------------------------------------------------------------------------- |
| note      | set pitch as number or letter | <MiniRepl client:visible tune={`note("b g e c").sound("piano")`} />               |
| n + scale | set note in scale             | <MiniRepl client:visible tune={`n("6 4 2 0").scale("C:minor").sound("piano")`} /> |
| $:        | play patterns in parallel     | <MiniRepl client:visible tune={'$: s("bd sd")\n$: note("c eb g")'} />             |

## Audio Effects

| name  | example                                                                                 |
| ----- | --------------------------------------------------------------------------------------- |
| lpf   | <MiniRepl client:visible tune={`note("c2 c3 c2 c3").s("sawtooth").lpf("400 2000")`} />  |
| vowel | <MiniRepl client:visible tune={`note("c3 eb3 g3").s("sawtooth").vowel("<a e i o>")`} /> |
| gain  | <MiniRepl client:visible tune={`s("hh*16").gain("[.25 1]*4")`} />                       |
| delay | <MiniRepl client:visible tune={`s("bd rim bd cp").delay(.5)`} />                        |
| room  | <MiniRepl client:visible tune={`s("bd rim bd cp").room(.5)`} />                         |
| pan   | <MiniRepl client:visible tune={`s("bd rim bd cp").pan("0 1")`} />                       |
| speed | <MiniRepl client:visible tune={`s("bd rim bd cp").speed("<1 2 -1 -2>")`} />             |
| range | <MiniRepl client:visible tune={`s("hh*32").lpf(saw.range(200,4000))`} />                |

## Pattern Effects

| name   | description                         | example                                                                             |
| ------ | ----------------------------------- | ----------------------------------------------------------------------------------- |
| setcpm | sets the tempo in cycles per minute | <MiniRepl client:visible tune={`setcpm(45); sound("bd sd [~ bd] sd")`} />           |
| fast   | speed up                            | <MiniRepl client:visible tune={`sound("bd sd [~ bd] sd").fast(2)`} />               |
| slow   | slow down                           | <MiniRepl client:visible tune={`sound("bd sd [~ bd] sd").slow(2)`} />               |
| rev    | reverse                             | <MiniRepl client:visible tune={`n("0 2 4 6").scale("C:minor").rev()`} />            |
| jux    | split left/right, modify right      | <MiniRepl client:visible tune={`n("0 2 4 6").scale("C:minor").jux(rev)`} />         |
| add    | add numbers / notes                 | <MiniRepl client:visible tune={`n("0 2 4 6".add("<0 1 2 1>")).scale("C:minor")`} /> |
| ply    | speed up each event n times         | <MiniRepl client:visible tune={`s("bd sd").ply("<1 2 3>")`} />                      |
| off    | copy, shift time & modify           | <MiniRepl client:visible tune={`s("bd sd, hh*4").off(1/8, x=>x.speed(2))`} />       |


